{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","name":"HatNFT","functions":[{"name":"__aztec_nr_internals__constructor","hash":"11025576168322401632","is_unconstrained":true,"custom_attributes":["abi_public","abi_initializer"],"abi":{"parameters":[{"name":"chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__exists","hash":"16379421579651172754","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5PIqRdARZkRc9NWzVGz+KqIiLWlEvkiItsiIvKg0rDSsNKw0rDSsNKw0rDSsNKw0rDS8NLw0vDS8NLw0vDS8NLw0vDS+NURqjNEZpjNIYpTFKY5TGKI1RGiM1onDpIiriolbUi6RIi6zIi0qDSoNKg0qDSoNKg0qDSoNKg0qDSoNLg0uDS4NLg0uDS4NLg0uDS4NLo5VGK41WGq00Wmm00mil0UqjlUYrjV4avTR6afTS6KXRS6OXRi+NXhq9NKQ0pDSkNKQ0pDSkNKQ0pDSkNMrnvXzey+e9fN7L51H4ZC1IirTIirxoJIXPF1ERF7Wi0rDSsNKw0rDSsNLw0vDS8NLw0vDS8NLw0vDS8NLw0hilMUpjlMYojVEaozRGaYzSGKUxUiOKoy6iIi5qRb1IirTIiryoNKg0qDSoNKg0qDSoNKg0qDSoNKg0uDS4NLg0uDS4NLg0uDS4NLg0uDRaabTSaKXRSqOVRiuNVhqtNFpptNLopdFLo5dGL41eGr00emn00uil0UtDSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLQ0tDS0NLo3wu5XMpn0v5XMrnUj6X8rmUz6V8LuVzKZ9L+VzK51I+l/K5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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__get_hat_metadata","hash":"12658039321073104230","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__get_minter","hash":"3708716369551405810","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__mint_hat","hash":"6220045117227927446","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"winner_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"loser_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2468625083757737193":{"error_kind":"fmtstring","length":22,"item_types":[]},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__owner_of","hash":"5643578972460481564","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__total_supply","hash":"8947727259520528857","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+29CZgd1XUuWtV9uukjtfq0JoSQQN1IAiHMIDGDAAkJgWQNgJAExjYIIwMORhhEjJjsBgQCJGGM7Yz3y3ATO7nPuf6c+Drjy5eJ5NmJ4zi5L048O06eY8dOcGJn9HWeK6ql/vvvv/bZVWcd6YBOfV9/Xaf2Wv9ae+211157166qNDl0nJL/v+WWHQ/t3vmmW+6575a77tm98757dtx9/y237N61e8fdt9z/wL333r0no0pz6loy8UiTJkcauBavwuLFhygHco4eQOr9/t9IEnWkA6RBOf533jTAgKX4k//iT5Oq8g/VP+OpWP+kP/9/I/CjLoZ73Pf/BuHcWmowwN+ibjcOAE8F/nRGgXzTLTtWA8NIEnX0Ge8axfvt+z/9/j888Eu/93O7P/Cz75v+mWk/MvU1U96xd+8/zPv7+T/68t7/brxXgU5pEi273/jXKtmX/3Lv6+788L/vmnr1Ex96+2f+ctMD0+bv+J0F+372dS+9sOBrtzxlvFcr3r/d/2PvaHzo3T85csYnvtN/9fPfuOWf1vVd9JlPPDL3dx//7tdeftF4r1G8f/q6737+I40XH3rwwK8+fNGSmTs++OKnv/X1P/jD/9n4py//wts+fb7xroM6V+mj66vxDxv/a4G/lpTrY9mxoRr/Yf03VuPvMf5NcHHETsZ+5uc+v+rAJ875ynenPLtxx5MPnvvcn23/5kMnfGDx37zlF+Z/cLrxbla8f7V79Qu757z1gm8OfPLAsp+ad9IXv/2Bj3z1n/fsvOgbX/3bj47+k/FeK3hPWH7axff+8J/M+tySUz678rc+eNZ75n570YrP/co1P/Xyv3/sX5Nxm10HdS7RZofrfH01/prxb6nG32v8N8DFkTDP4YHNeLdWk32Yf5uQvXRF/eWfffaxvcmXPvB3B/956W+sPHP6yaumn/W/f+zP591z381zXzbe7dVkz5+SHIrvf7Ho0IWp3//LT5MHdt91912796y6//6d9+1eveut9+7Yfddtd+/cfN+ON929c9vO++6/a9c9DMij/eqC65mcEybKuXrn7q2Hzlbv+n4S8ODuPsJN6XcP/e6l3zX6bXh9BXzM0+wYzHn6CU/9T0iOHVaHBmFhfQcTXX/1P1YO5x8o5zgHOTaWY740kkQdaYP0QBzDrUNZifH0WuOfUo1/p/FPrcZ/n/EPVuN/s/FPq8a/y/iHqvG/1fgb1fjvMv7havz3GP/0avx3GP+Mavwjxj+zGv/9xj+rGv8O459djf924z++Gv+bjH9ONf4fNP4TqvHvsRg1Fy5a/DHsE+F6ibHwpJgYh/h10qWkvDQlPJPH9bOYanWfJ3RpiDKOkfOEnHlCjsKa4og11RFr0BFrWofWccgRq+GINeyINd0Ra4YjlqftPfvQzA7FmuWI5ekTnrb39K/ZjliefdvTJ453xPKM0XMcsTp1fLQ8y3IHzDXSgv8mh6+ZnDphpUm1vEfV60QhL0Q/N0A/PxI/s7f1nXwtYs3O2x64Y8OuOxI6eHngqgIV5xPd1oBqjJvSXxLgNdMzLR5Z9awL5tVbu3P3m+68Yccdd+y8/fuVvJ85GGlNwXVOSJFmgLQt6SQ9MU6J+PVksvNXcUrlNKqzZVa1gSC36oZdO25fvePe+x+4eycvTeEUga2CqHhNtWkKmuG1XqJbQ7/XCb5EYKMvnQRlyhKGOZRMrtNJBXzcZflaj6CfT1jzBZ/p3hvgRwzkY48JeXWMV1o9skOFZJM9kEy2x0gSd5iOHAsQ9yS4XqInzIrteYZfT1rq6WnI37B+vLR4cjV5M1PiR3mIafqYrReIMsMayX/3F2AZb43ofzr/3xAyOGZYGeqL18w+2fL2fyPd0bbsJ63YEfFML7yG+PWkJb9MQ+2G9WM/WVBN3owYu6M+ZusRUWZYo/nv/gIs460R/Yfy/w0hg/3EylBfvIZ+8j9Id7Qt+0lFO66K9RPDryct+WUaajesH/vJSDV5K2PsjvqYrUdFmWGdkv/uL8Ay3hrR/0b+vyFksJ9YGeqL19BPfjk/HyjQdySJOu5Wti7B//aBZHK9SvDvNv5TqvHfafwLq/E/bPyLqvGfY/yLq/E/ar53Klzkfn4aXC9zKzm2nxt+nXSp2s9PI3lcP14+XyJ0aYgyXj5fIuQsEXIU1lRHrGmOWMc7Yk1xxJrZoVgNR6xhR6zpjlgzHLEWOGJ5+n2n2mvEEcvTV0cdsU5xxPK0vWcdZzlidaqvLnTEWuSIZbmRjfeYH6T5/wHBV3ZuiHimJ15D/DrpUlJeGrIL1o/nNKdXkzc9JX6Uh5imj9l6qSgzrDPy3/0FWMZbI/qpuUEbQgbPaawM9cVrOKfpz3GHhL68vlPWH5GfbYR87I+ttBfimZ54DfHrSUv+n4b8Q9nF6re0mrzhmPZFfczWZ4gyw3pN/ru/AMt4a0Q/j/wRZbA/Whnqi9fQH49PJ+qOtmU/qWjHq2L9xPDrSUt+mYbaDevHfnJGNXlrYuyO+pitXyPKDOvM/Hd/AZbx1oh+CfkJymA/sTLUF6+hnyzMcQcK9B1J4g7uI4aB2KhzfDuk34r1M8OvJy21exqyo+pvVr8zK8lLX2bfQHmIafqYrc8SZYZ1dv67vwDLeGtEfwH5Gcpg37Ay1BevoZ8to3iEtmU/qWbH5MpYPzH8etKKX477iWo31d+sfmdVk7cqxu6oj9n6bFFmWOfkv/sLsIy3RvSryU9QBscjK0N98Rr6yeUUj1Df7BhJoo5U2boE/yTbIYZhnwPXS7Tjf8b6qeHXk8k2ruKn55C8onawui8TujREGdoYy1DOMiGni9XF6mJ1sbpYXawu1isb68wu1qsC61jwr24f6rZjN050++MrFavrX11fPRZ9tZtPdO3VrWPX9q9UrK6vdn3iWLRX17+67XgsYnX7UNcnjkXbd+Nqtw917dXFaobVnVt169iN0V1ffaVidf2rq1cXq9sfj2Qdu1jdmNMdh7p17NaxG3O69uq2Y9e/XrlY3bWObh27MacbJ7pYXb/v9qGu7bt9qIvVyb7azSe6PtG1fdf2RxKrOw517dXtQ12sZlid7hND+W98Zxh/z0W9n+ucgBzkN7pBwZfm/weEfpmckSTqiH5vmeHXk8l1LiEvDdlf2cXqvlzo0hBl3M7LhZzlQk4Xq3WsszoUq1vHV4e9jgW9ulivjv7YjRNdrK6vduP9kdSr247dOnb9qzt2vFL16vpE115d/+q2Yxer24e6PnFs2r4bV7t9qGuvLlYzrO7cqlvHbozu+uorFavrX129uljd/ngk69jF6sac7jjUrWO3jt2Y07VXtx27/vXKxequdXTr2I053TjRxer6fbcPdW3f7UNdrE721W4+0fWJru27tj+SWN1xqGuvbh/qYjXD6vpEF6uL1cXqYnWxulhdrFc71lD+G98Zdg7JKft+NOQ3OvVusuxvJIk6bhgQdSjBf4vxn1uN/23Gf141/gft3WXnw8U0/2/YF8D13njsZSnhJTk/XkP8OulSUt7h97ZdQPK4fuYXVvcLhS4NUcY+cqGQc6GQo7BOccSa4og1wxHreEesBY5YsxyxGo5YQ45Ynj4x2xFruSPWTEescx2xpjpijTpiefbthY5YnrHQsz8OO2J5tuNiRyxPn/C0vWff9qyjp09Mc8Ty9C9Pe3nqdSzkTN0x7ejZ3rM/DjpiedbxvA7VyzOf8KyjjbVqLpz9jSRRxwM81zQMxL4IrpeY916eEl6S6Hm24deTyfWsMs++iOQV2dXqfrHQpSHKeJ59sZBzsZCjsE5xxJriiDWjQ+vYcMQadsQadcTytP1CR6xuO5bDWuyI5ekTsx2xpjliecavmY5Ynrb39FVP2486YnWqr3r615Ajlmc7evqXZx/y9K+pjlizOrSOnZrLedbRM5/o1Hbs1FzuPEesTs1zPHPMbj7x6uhDnnHCUy9P/zrXEesCRyxP23vmADbW2jrQucCX5v9bXAMbTQnP9MRriF9PJrel1xoY1s/sYvW7uJq8kZh2QH3M1peIMsO6NP/dX4BlvDWiX91/6H9DyFhKMqwM9cVrZp++7/9dnuMOCX25zym7XyRwG4KfbYR87I8V26s31h8Nv5605P9pyD+UXZR/GK9qV7Z/bLuGsHhd2MqzY0DwlbBHI9b+hl9PWmrvNGQXFSetfpdWkzfEfRjlIabpY7ZeIcoM67L8d38BlvHWiP71FA9QxlySYWWoL17DeLC9f6LuaFv2k4p2rMX6ieHXk5b8Mg21m+o/qt2M19PeRwqL2ys7RpLgYc0xyRbZwX5wGVwv0S59sX5g+OYHK6rJS7nPmbwim1rdLxe6NEQZt93lQs7lQs4rCct8aDCZ7FNOfjG9ql9UjEdBv8D68ThyeTV5wzHtgPqYra8QZYa1Mv/dX4BlvDWif5zGEZTBeaWVob54DceRRymvRH0vJVxl98sEbkPwG92rTc6g4OP+VdH/ouOu4deTlvpzGvJ3ZRfl78ar/JTtH+unr0Qs87/LA3LKxnfkv/wIy1G+nP2NJFHHOuO/ohr/Jca/shr/RuNfVY3/KuO/shr/FuNfXY1/lfGvqcZ/tfFfVY3/RuNfW41/k/FfXY1/jfFfU41/g8WqdXCR4/R6uF4ibm6KjdOGXyddqsbp9SSP68dx+rVCl4Yo4z7+WiHntUKOwhp2xJrjiDXLEWuBI1bDEWu2I9YMR6whR6wpjlgzOxTL01enO2J52v4KRyxPX/Xsj6OOWJ3aHy9wxPLsQ51q+1McsTzjhOdY6xknPG3vaa9O9S/P3MSzHT1tfyzEiYWOWCsdsVY5Yl3ZoVirHbHWOGJ52n55h+p1lSNW3RHL0yfWOmJd7Yjl2Y6eenn66kpHLE97LXPE8vRVz3b01KtT7eXpq9c4Yq1yxPKMX4sdsTzzr0FHLM81Bc+c3HOu4Ln2aPm9rWPjunea/x8QfGX3jCGe6YnXEL9OupSUl4bsgvXjvQwbqsmblhI/ykNM08dsvVGUGdam/Hd/AZbx1oh+63GH/jeEDN4DY2WoL17DvQzX5rgDBfqOJFHHWmXrEvyvYdsZBuq2Ca6XaMfXxPqp4deTyTau4qebSF5RO1jdNwtdGqKM22izkLNZyFFY0xyxLnDEGnbEmu2INcMRq+GI5WmvOY5YsxyxFjhiedq+U/1ryBFriiPWzA7F8vTV6Y5Ynrb39K9BR6ypjlieY5pnH/K0/agj1nkdWseFjliLHLEWO2JtcMTq1NzEMxZ65jmeccIzfnna3tNe1o62fxbjBu+fPU/IOS8gB/mNrsV30d9r8yqcv6eEXXFOOT8lvCSJm1NWXIsIzimxflXnlHyf59U4lh/viHUs5MOdHoc6bcz0zKM6dTzp1LWBUUesTp1vdWrucyzY3nMe6BmjOSfDfOZEkqNyh00BOchvdCpvyv5Gkqjj+gFRhxL824z/2mr8m43/umr8qy2vuh4upvl/w94C10vkeGMp4SWJzikNv066lJR3OKfcQvK4fpxT3iB0aYgyfibmBiHnBiFHYQ07Ys1xxJrliLXAEavhiDXbEWuGI9Z5jlhTHbE8bd+pvjrqiDXFEcvTvzxjzjRHrGPB9kMdWseZHYrl2benO2J52v4KRyxPX+3UHMATqztul8PqjttHz7+64/bRs3133D56fbtTx21Pe3Wqr17giOVpr1FHLE/bn+KI5dmHPMftTo3RnZpPeNbRM/f1bEdP2x8LcWKhI1bdEWuTI5bnOvlmR6zVjljLHLFWOWItd8Ra64h1rSPWsWD7lY5YVzpirXHE8rTXdY5Ynr7q2Yc61e87tY7HQiz01Ks7drw6xo7XOmJ55nKe9rrGEetqRyzPsdbTJzzt5dmOnnFisSOW55xv0BHL856O5zqA5/qE5/4cfm8E7g1L8/8Dgi+TM5JEHVNTwjM98Rri10mXkvLSkF2wfmYXq/tWoUtDlPH7F7YKOVuFnC5WF+toYdl+YezD/AxX2TiC/EY3KPg4jqB+Jfr1otg4Yvj1pKW4lYbsr+xidd8mdGmIMl6f3CbkbBNyFNZUR6xpjljHO2JNccSa2aFYDUesYUes6Y5YMxyxznPEmuWI5dkfRx2xPP3L014LHLE8/cuzD3nGVU+f8Iyrndq3PfujZx+a44jl2R+PBf8acsTyzAH4GT/Ml/kZv7JzA+Q3ukHBl+b/B4R+JXLoF1LCMz3xGuLXk8l1rpKzK/sru1jdtwtdGqKM13u3CznbhRyFNeyINccRa5Yj1gJHrIYj1mxHrBmOWOc5Yk11xPK0faf66qgj1hRHLE//8ow50xyxjgXbD3VoHWd2KJZn357uiOVp+yscsTx9tVNzAE+sTh23PW3vmQOMOmJ55hOd6qvdcfvoxdVuTl4Oa44jVjcnL4fVzQuPnn91al7oaa9O9dULHLE87TXqiOVp+1McsTz70BxHrE6N0Z06pnnW0TP39WxHT9sfC3FioSNW3RFrtSPWJkesZY5YnveHPO11jSPWckestY5Y1zpiefrEKkcsT9t79m3P/ujZhzY7Ynn2x2PBv1Y6Yl3piLXGEcvTXtc5YnnGQs8Y3al+36l1PBbGWk+9urnJq2PseK0jlmc+4Wkvz5z8akcsz7HW0yc87eXZjp5xYrEjlueawqAjlud9K891Js/1L8/9hfyMLu5tTfP/A4IvkzOSRB1TUsIzPfEa4tdJl5Ly0pBd1D5pq/uNQpeGKONnKG8Ucm4UcrpYXawyWLZHH/vdJSSnbN9H/u0BOStalLNCyBkUfBxj0A4l+vxvx8YYw68nLcW0NNTOyi5Wv5uqyfutlPhRHmLeSPJeV01er7XV6wW26fKG/Hd/gS7GWyP638gHVpNxs+BpiDLuY1aWgHy81nOUsF4vsNCO1iZ93//7xdwWyv+zv5Ek6lim/KsE//JB0s0wUDescwlf2h7bNw2/nrTku2moTbF+PP6/XujSEGWr4bxZe6MchTXaoVhTHLGGHLHOc8TytFfDEWvYEWu6I9aMDq3jtA7V63hHLM/+6NmOsx2xPPvQTEcsz3b09NU5jlie/jXVEesERyxPv+/UmONZx4WOWIscsRY7YnnayzM38fSvUUcszzjh6feedfQch2Y5Yi1wxDoWcrlO9XvP3KQ7ppXD6tRcrlNjoWcu5xkLPdvR016dmn/d6IjVqfnXoCOWZ9/27EOe9vIch0YdsTrV9p7xy3NdrlPXhjz9yzP37dQcs1PHjpscsWzsGCRsK8+OFu83nZQSnumJ1xC/nkyup9f9Jqxf1ftN/CxFp8RDz37UqWvlnjHME6t7v6kclufanGcf8mxHz/sBnrnOqCNWp+Y6nnp16n2dTl2j8GxHz70KnvGe39uLuRG/t7fsXibkN7pBwZfm/weEfiXypb0p4ZmeeA3x68nkOlfJz5T9lV2s7m8QujREGT8D8gYh5w1CjsIadsSa44g1yxFrgSNWwxFrtiPWDEes8xyxpjpiedq+U3111BFriiOWp3956uXZjp56ecZVT5/wbMchRyxP28/sUCzPODHdEcvT9lc4Ynn6aqfmE55Y3Rzg6I0d3Rzg6OnVzQGOXjt2c4CjFyc6NQfwtFen+uoFjlie9hp1xPK0/SmOWJ59qFPHjk7NfTvVvzzzaM929LT9sRAnFjpi1R2xNjliea7fb3bEWu2ItcwRa5Uj1vIO1cuzHT31WuuI5ekTnu240hHrSkesNY5Ynva6zhHrWkesTvXVVY5Yx0J/9Kxjp/pXdxzq+j1jvdYRyzPH9GzHaxyxrnbE8hy3PX3C016d2h8XO2J5zkUHHbE871t5rk94rpt47meytQ7bf4h9it9JuFzIWR6Qg/xGNyD4RpKo41Lbv3c5XEwJF++L98Zj11LCS3J+vIb4ddKlpLzDexevIHlcP7Op1X2l0KUhyjg2rhRyVgo5CmtuG7AGCvQcSaKOraq9S/D/ANvTMFA3HKtKtO0Jsb5k+PVksp2q+NKVJK+oXazua4QuDVHGbbRGyFkj5CisYUesKzpUr2mOWCOOWJ51nOGINeSINdMRa7ojlqe9Rh2xTnDEOs8Ra4ojlqftG45Yszu0jgsdsRY5YvEzxphD2rjaWh6YfiklPNMTr6XJ5DxweSV54TxQ5dat5SbpF1PiR3mIafqoXIHHXZs79xdgGW+N6KflA6Vq66UkI9ZvsncvD+S4Q0JfntMou18hcNWcxuiUnBUtylkh5AwKvjT/32LO+pqU8ExPvIb49aSVfhbOWZVdyuasvMbXKfncBY5Ynvlcp45FcxyxZjliLXDEOhZyik6dX3nqdbwjlmf+6zkn8vSJQUcsT5+Y6ojlaS/P+NWp81HPdvTUq1PHDs929LS9Z98+lua2nWavTh23Rx2x2jHW2nzlSuBL8/8Dgq8dczXDr5MuJeWlIbtg/Xiudo3QpSHKeH/BNULONUKOwmo4Ys10xDreEWuaI9YcR6wpjlhTO1Sv2Y5YMxyxFjpiLXLEWuyI5WmvYUcsz/446ojl6feesdCzHQcdsTxjjqdPDDliedp+VofqdZ4jlqdPeOYmnuO2ZzuOOmJ5xi9P//Lsj50aoz2xPP1ruiOW2d7u3+F87FySU3ZOiPxrAnIublHOxULOgJCT/Y0kUceXjf+aavw/afybqvGfbvybq/H/ivFfW43/o8b/+mr8Y8b/hmr8bzD+N1bjX2L8t1TjP9f4b63G/7fGv6Ma/zXGf1s1/l81/jdV43/B+G+vxv8d499Zjf9F439zNf6Xjf+Oavyp8d8F/CXWi0aM/weq8feavm/Bi0Inw7f1pjuBPi34b1hcZrLqhFVS9zSkO+rHcfwtIA/rWIT1lpJYA6KsSpvclRTXC/EHA7ooPXnNoZU6z3bEWuuINdURa40j1o2OWNc4Ym1yxNrsiFV3xFrliHWtI9brOxTrKkesNzhivdER6xZHrFsdsXY4Yp3giHWbI9Z5jlhvcsS6zhHLc+y43RFrpyPWmx2xlnYoluX3tq6A49IWklMXcuoBOchvdIOCL83/W365Cq6XyC9PTwnP9MRriF9PJte5Sp6+iuQV2UXtPzZetQ+A333Qyp6CUxyxPPeaduq+Qs99mJ2613TUEctzv6PnPjnPdvS0l6eveu7X9vTVKY5YnRonjoW9bZ728nx2xdMnOvVZUc/nYT1jtGcO0KnP54w6YnWqf3X35laLOTZfwhydnwtdJuQsC8hB/mUBOStalLNCyBkUfGn+v8V52bSU8ExPvIb49WRynb3mZcou6l53CXmDMX6F+pitrxJlhmX3DPoLsIy3RvQ/lG8saQgZ/A4eK0N98ZrZJ3se+t1DE3VH27KftGJHxDO98Bri15OW/DK4Jx3rx35yVTV5U2PsjvqYrdeKMsOyeyX9BVjGWyP6nyE/QRnsJ1aG+uI19JOfyHHVPhWOj2XjMPIbnZKzokU5KyLlrG9RznohZ0DwjdjJt+//9Pv/8MAv/d7P7f7Az75v+mem/cjU10x5x969/zDv7+f/6Mt7f6ZF/9xu/Gur8c9Ue35K8M9Qe35K8E9Xe35K8K9Re35K8K9Se37i+dOE9/wkSfm6v7GS7GSl2u9Tgn+B2u9Tgv97ar9PCdu9rPb7lJD/f3i/T4K8l/9y7+vu/PC/75p69RMfevtn/nLTA9Pm7/idBft+9nUvvbDga7c8rfb6lJDdp/b6lOCfovb6lOCvq70+Jfjn8V6fJJ63R+0p6YnnH1D7hErwX2D8d1fjv9D43woXR/L/i/781477l//xfO0X/+LlXW//ztIXP371gd/8v1a8+xNnXv7OLV95399vNN57QHaZvNr4d1XjHzL+e6vxH96j9bZq/Ifb7r5K/OkXjf/+SvzJoPHvhosjdvK3+3/sHY0PvfsnR874xHf6r37+G7f807q+iz7ziUfm/u7j3/3ay+8x3gcUb1jvw3H+BxXvn77uu5//SOPFhx488KsPX7Rk5o4Pvvjpb339D/7wfzb+6cu/8LZPH/bXtx9GK5eDGv+D1fhnZTnepyjH6wGseXCe/dXy333JeC6/FWj43lgfCEvz/6bznmo696SElyR6XmH4ddKlpLzD84o9JI/rx3V/SOjSEGWWn1tObzb+cL6Qlsn4HM3XekAu27UG10vUc26sXQ2/nkz2lyp2rZE8rh/b9UShS0OULYRzLEM5Jwo5CmuxI9YMR6zzHLGmOGINO2LNdsRqdGgdpztidap/zXLEmuqINeqI5elfnvZa4Ijl6V+efWiaI5anT3jGVX6XCPKl+X/LAzB3a0d+Zfh1oWeVPGAeySuyS9b3zQcf2H3X3Xft3rNh147bV++49/4H7t7JmRFmQ2wVRMVraTKx9ljWS9d6iW4t/V4n+BKB3Qty50OZsoRhWsaOdZpfwIe2SMS1HkE/j7DmCT7TvTfAnx2DQoej7bEVM+Wgx2L9OHOdL3RpiDK0YVHEUBlyWb2mJuMjVt6T1uy87YE7Nuy6I6GDXeeqAhVPILp1BaqlAjelP75+Al3rTcJdNTRZinGZJJkcjBFrK8npBuNuMH5lBONewcceMySu8xbysqnMFiFPydnWopxtQs6A4Buxk7Gf+bnPrzrwiXO+8t0pz27c8eSD5z73Z9u/+dAJH1j8N2/5hfkfnJEtwVzRmKgv2p8DsLV7XxJurxrR/5/jx/lW5/KyHmZbqvIeduUDd//A9Tt333fXzh/c+f1YfX9CR7NusYl+bxZ86ogZwysGnuhAZ/heY7hyraKxMj7QsUOgVRAVr6VJ9UC3mX5XCXTNsgYOdKHghK3SI+TatZ6kOBCpIMZrjaFAlh3dofnQUd5jj+WhOcZjY4fmIo8tGpqZry8p9vAa0d6aDxktevaE1UjWsTsGHDq6Y8ArZQzoFXzsMSGvjvHKJJmchKr6DyST7TFiJ3+1e/ULu+e89YJvDnzywLKfmnfSF7/9gY989Z/37LzoG1/924+OfrvF3rWtxaiwNYtEuykJxlULntydmv8uuldsvDWi39cY53sQkmC7B5f3vG077r7r9h27d151z9se2PnAzts37dq98/5V99x+1Q/uvGd36ZT4avp9jeBTh7pp3k9l6CwplaFzHZefx4TYijezo0Os4XuF2D6SVyLEbtm9674dd+y8fueO2zlMohX4f1EYZauyZ6T0m0PXOoGTCFm9dJ4KvJgQmwpdepNiz+Kw2CN0SkinpIB2CtAsF/WZL/Q2envdXT/IRRru/ka/P+/yWW/4wqJD5yqkmj6DxG/l2WG95XzSfSSJOqJ7i+HXSZeqveV8ksf1q5aQYLBmqyAqXgv1pCORkFwIZcoS3FuwThcW8LHn8rUeQX8+YZ0v+LjnKX7EQD72GO5FuJK0XMjmXvTfoBd9eVGxXPygIOtiv3uEPOt1FxJtdlivu4jqNJJEHdtje53h10mXqr3uIpLH9avW69BTUMo2QjUapMVjG2iG9PybW+9EwceH4dRI549CKvYBSv2wXqeR3srb8RqnyshvdErOyS3KOVnIMU8+FcrOorIlgbLToew0KlsKuvDdojOAby6VnZ1MrrOVnRPAXCYws7bbOjx+PftbAxjK0zmqXgm4yIu/+wTtQH5eI9qPgV/9OvkV9mL2qwub6B3yqwuTYjkntyjnZCHH2gT9l33nIlFXK7sY5HE7Xwp87DuXiXpZ2eUBzJUCM2ufDcMT6bj9s6PFR5W2xUZ8w6+TLlUjvnp0Tz3i1eKjVFtT4kd5iGn6mK3XiTLDssfN+guwcJ6C9H+e97eGkMGPCloZ6ovXcJHyU42JuqNt04L/hsvXuH+FHqe8Evi2gj6fbUysC8ap3mRyrLJlEY5VX4d7cl+gWIX83Haqn1St/xpRx6Fksm1OgvMi/74qIOekQH3a1Z4nkRyMs9ieX6f2XAtlHKOzc1vB4Ueq/wza85vUnqovKjvzuFTWzqcJOe22M48v6xzlIBYu8WV/GwiL7WztZHbGx2g3EN9GKEM6nHVtgOsbhWyFbxjNfPB7DV23Ih80WTWi/xXwwXR4Yv1jfZBzNIzj/Fi56YF2QHp+Ra/p2V9AX1Svgbwu2azzrxdNxDR+tBW2Bcdfo58KmF9dpPXEeuF4wLdglD9sEPVSNt2YNJeNdl5XILs/CftijehnCJvyuID8qh+9hnRZ30R37t/Ib3SDgq/VOKJ0btYn59HcplmftMfB2Xd/CvrkydQnQz6COvM8oqydTxZy2m1nniNsdJSDWDwuXE9YbGdrJ7PzZii7nvhugDJ+XUAv8SA9Yij82HHh7GFdtyIfNFk1on8KfHA5+aAaV5QPbqQytCmPC83iIb8+3PTuT8LjbY3oLw6MC6q/YqzlccHoVwTGhc2iXqFxQfniZlEvZdPrCetKgYV25nFB2RTrfyXV3+hXR44Lxq/WI86kMlyPWEtl+FkhzllxPWIdleF6BK+NXA5lHO9WQhn6CK9HnBqoD67b8XofrttdRGX4SuaLqQzX7S6lMly3u4zKzoGyy6kM1+1WQl1t3Y5vkd+YX2/x/pbc6FO0Lsp0+D9J4saDU0lPlHO+oxzEYj++0FEO33FAORcLOdZelxLfSBJ1RN+PNPx6MrnvVlknu5Tkcf2q3RnBaMNWQVS8liYTa49lR+J+5GVQpizBszKs02UFfGiLRFzrEfSXEtalgs907w3wIwbyscekdL3ofqRh1Ij+bTBafZ1GayUL7cEjpuletLOAdTD6B0CHLyzSmLWCel1cgLlveNweDw5rzERgqnpdRvViHS4lHYz+EZEJ9BIN66OuZb8xM7qsQD/VTqwrjnJF9eF2MvrHA+10kdAB++S6JjowzWUFOjwldBDRbfWue/fk0S2ho9k+I7Y837e9SOAUHYafeaF5pFpru1jw8TiFHmC8Wc3tcfTDDwrevXP3zoK69wjdlEzeW2VHzBi6jvBHkqgjegw1fK8xVN1LUWMoz/eRV83f+XNkayPlZG1qj5PDTruiJo0dXFOhVpIUD7JpMrEpkIffmIllR8sNKt4CDLqBevtmuVSKvxmLVkFUvBayfLPW9nh6Qy2OrRWYajF2fQFfsyDXI+jXEdY6wWe6h260IgbyscdwDylKpTjlMPqfgaHJtnYxj/1+E5zz1i11A8h6Fd9cGUmijumxvcrw60lLvTgN+ZK6UV2uV3FoNSnDhGo0SIvHMGiG9EXDoh3rBR8fhsNe8muQmP4CLSWid/KjtqhDaPhQj9ryUgluagxtfeEtLLHbW7js8kDZykAZ3sbfRmXq1jvfqkXMzN490yfSqfErpqdkBy9VqttO6OkcNYtud2Z/G5tgXUdYaqnXsDY3wdpCWMjPucP1TbCuJ6yipfvs74YAVnZ+O2Gp2wTqrdrMh7cgtkTogNdCj8kb3aDgq+pLjYDOoe1nmW9/kia5WKZGP0ska0S/C251/CnFJ7xVZDoqO3PsKmvnbUJOu+3M8eUmRzmIxbfbXk9YbGdrJ7PzzVD2euLDr6QiHWZI+NbsNwjZCt8wmvngV4Z13Yp80GTViP4G8MH/LzBGhnzwJipDm3L+cJOwg2qDlPTuL6C/iepl9N8M3G5T/RX14q0dRv9y4HbbzcnkeqnsK+SLN4t6KZvyl4NV9o314QUhZdObgIa3TRr9vwRut6nZgMqBQrfb+PYX5kAbqAxzoI1UhjnQZipbCWXXUxnmQJzH4e1EjpOYA6FvWQ7ED6b05dcHksn9rETmL29dGdZQMtn2eLsPy5Jk3A/UI1YNwX9uQM7ZLco5W8gZFHxW7xbtGL0OYvhej7ipeYayC+fQyKv6Hy8q2y3gZ3OHyXxzFuXn+DAY25VvWY4kUccFsXY1/DrpUtWup5I8rh/bdYnQpSHKXgvnWIZylgg5CmuaI9YFjljDjlizHbFmdGgdPdvRs47Hd2gdhxyxznPEWuCINcURa9QRq+GI5ekTnv3Rsw95+oSnvaY7Ys10xPK0/aAjlqftpzpiedrLMxbOcsTytNeoI5ZnLPS0l2fMORZyJk+f8By3PW0/4ojl6feetj/FEcvT9p519IwTnjmAp70WOmItzs9tjQnXIc4lOWrOf2pADvKfGoGl1g9CdSx6VZH1vxbfNW8qnk906wpUSwVuSn98nXej9wpaxMaX47Vx29LylPCSpLO2LZXdvXYdnGMZygk9MYdY0xyxhhyxznPEWuCINcURa9QRq+GI5ekTw45YMxyxPH3C017THbE87TXoiOVprwscsTx9dbYj1rHQjlMdsTzt5TkOzXLE8rTXqCOW5zjkaS/PeO/pX54xx7M/evrEFEcsT9uPOGJ5+r2n7U9xxPK0vWcdPeNEp+ZfCx2xeJkE59W8TBL7Nju1TLIuAkvNh0N1bPMyiam4jOjWFaiWCtyU/vj6MrrWbJmEd+X8O+0Gq7irSO4G411auBx0ZTKxHmVX6pB/SUDO6S3KOV3IGRR8Vu8W7TgV7Yd64jXEryeT61xleUntklN2UbvBjFftBuMXWoZewIlyulhdrKOFFdrtGdM/lRyMBzFxpKocxOIXlWJdOf6WtRvyFz0AjTvccWc9vwSLP+jBmGdBOdKfmudE2Y7wb+Y7wps9ubBkRnNdLxa68tN9F8CTC2fkmMrOHBvPFXXktkO5CpPHtLJtd7rQIYSF7bWU6K0t+gvoDY/b7nxoO35CQr0oeGdAZ+U/qEOR/1xcwX8undFcV/SfpSTb6E8A/7mc/Af5Q/7Du7DRf8xGKic6O5lYh7I5EfKHci9+4bvSPaUy1CG0S1/ZSMnZ3qKc7UJOu8eH7UdATnbw+IA6vA7Oq9gN+Y/00xq9Qg5+tCH0IjLL3yu+2L4W0y6I7/XplGYflOD8Xb2suCHKWp3CI9YSRyx+NZLym9cJrLL2clwOMBW3Ed2WAtV6BW5Kf3x9G10rWg4w7KMZmtvR9ZWcS1qUc0mknBUtylkRKafeopx6pJxXm91eyfXh96JmB6alT8zQMjEtxdTdhkN+OPTC2eN8T1FaivxXJBPlLRV1XBqoI/IbnZKzvUU52yPl9LUop0/ICWFdIbCM/hxB3yfoHYcmU/EMoltXoFoqcJsNTWfQtWYr1UfTHdohx7qaPYO+Pb/TlDXtj+ZdjV9VbBjZYZkpvqq4RKZ4bkp4Vhe8hvj1ZHKbV8lMl5E8rh9npucKXdQs6Wo4xzKUEwqziNVwxJrpiHW8I9Y0R6w5jlhTHLGmdqhesx2xZjhiLXTEWuSItdgRy9New45Ynv1x1BHL0+9nOmJ5tuOgI5ZnO3rGL097neeINcsRy9Neo45YnvmEp70WOGJ14+rRi6ueth9xxPL0e0/bn+KI5Wl7zzp6xonpjlidmq/e6IjFmyBxjs5rCWo+vCwgB/mNblDwpfn/Fneg9aaEZ3riNcSvJ5Pr7LUDTdmF794hb0OU8Q6hsp8WRyz+YI7SWa1thGSrOrbhrtNyoruuQLUegZvSH19fTteKlvYM27oJLi1dSZhqFVSZVm1IOicg5+IW5VwcKef0FuWcHinn7BblnB0pZ3uLcrZHylnVopxVQk6vkIMbnZrdXTlt5qFzW8K1DUU7Zo7TnD5zYp3wZvepVF985P/8gA4c0vHLdyVCbPQrJg2/TrpUDelnkDyuH4a7+I8CcM9CqyAqXkuTydEoBc3wGm/HPJX4qnxq42woU5bgl8Zjnc4u4ENbJOJaj6A/g7DOEHyme2+AHzGQjz0mpetFn9owjBrRX5r3KvXVMiUL7cE3r0x326rINKyD0V8BOvDXsM4AHlUv7s1n02+MBAMF8m+AKLN6ppafCPlcP4yARV8EO4N0MPqrwQb8hbNzBH9ScA1tgLxFv5F2PtWFX9TKvshfQ1vWpO7c/ka/KdD+pwsd8GUt65rowDTzC3S4XujQ2tfQOMpxK3FLnC5wig6zRuax5r1sHe4dLMd+Kw9o9WtoSwpk9iT64C/WGl92DCQtjZXRY7Ph1xPteSNJ1JFy9DR5XD+ebp0hdGmIsqJe2kxOi19DKxq0VbDIjqLBO00mNgXy4CuG1MYfnsKUXVFAfqM7mhv0XslvbD9Se8EZq2jD1Rvzc95wdT8Edv6qw7mgh0oat5AOF4n6bBf1MfqVgv4iUUezJa6ErIyQjbbkgXBNSV2bPZdyEem6EsrWltT1uiOs67lCV/X1Kx5yKr5SLHrIMfy6qEOVISdkl/9SLP/f2kes+buXntPB7LiafleZDqqd72sEpnr6a10BH3s2X+sR9GsJS33HwXTvDfAjBvKxxyi+7PduwRPqATEenB1FTz14YK0XWNYz8TttJXrK7Nieafh10qVqz1TftFMvgLC6bxS6NEQZP/Ghvne3UchRWJc6Yl3miHW5I9aFjlhzu1hdrC5WFysSy8pwzF5PZaHvdmLs4hlq2XuuyH9hQM6qFuWsEnJCT4fyf5PD10L3kFdRfXDsZruVfTET8q+n+uB9Zry59ccztUycyeK9ff6eqNFfA88zfGpmcR3RzlYv1hmXwq2sRF4zmM2mX6Yn+jHH4cd9VP/BHO7t+bnqP+dQGbY1fzewqA0+S21wIZSpNjB9akS/DNrgC9QGyM+z8dC+BJTHPtJfQH8h6Wf0XxG3EZR+awrkoT3Qzg8WyPuqWF1RfmeyW/S72crvsL+y38Xm3bF+ajZRfrqSsNQ+JPQD9hHj7090Gxhejej/UbR5rJ9zuxr9dyLb1SmeyHZFW3G7roSy0DgU8oOVQMPPQWGbF61EIha2dUy7LhP43K52B0a1q/Fju6Ke3K5G3wuYoXY1W7ajXdFWMe2q9m+Fxu+VQMP71nCcPIOwVIwOrbCuzH/3J7oNOEYb/VCgXdUqdygOG/30yHZtZxxGW8W0q7oTENuuHIexXa+iMhzruC8fqRh9kmhzlfMvi9BP2c355t7aAjVmCf6EeFO6NqsAy3Cya7isyia36vYnegmUTW70i4TJVTdFfWK2/VZ8kUz0TQHD99r2G7slVn2ym7uZunnF7dRMjqOrZkfRU8qp4E8IKxXXsEy5qtpUxlsLeYQ+jWYK6EJF76pFmSrzN3rLQIuyC8OrEf0FgVEolAVnB0frzYIeM2PTR9V/M5Uh35oCOTg6YuTn0dHoL4scHU12O0ZHtBGPjtdDWa+gZ3vfIOivBxpeVboByrhLo403k5xmoYP9X/mpmn2rbPziQH2bzcrYv9AnNlKZms0pXzC6dqyUYH3YF0J9KTvYNiHfQds0kuZ+gv1yI8kJxaXsCPkCri7YatgAYKOckSTqOM34e6rx32b8vdX4z7R68ra/7DBsbNsSPvMmtIkdKlUw/DrpUjVV6CN5XD9OFfqFLg1RthrOsQzl9As5CmuGI9Z5jlizHLGmOmKNOmI1HLE87bXAEcvTv4YdsaY5Ynn6xBRHrNQRa6YjlqdPHO+I5ekTQ45YnnHVs297+uqoI5ZnXPX0Cc/45dmHPH3C017THbE87TXbEcvTVz316o7bR89envmqZ4z2zAEucMTyjF+d6hOecaJTxyHPOYxnHU9wxOrG1VdH/PJsxx5HLE97dWrM6dS8cNARy7M/eo61nu3Yqflqb4fqNeqIdYojlmec6NQY7amXp+07NU545uTHwrzWc9ye06F6ec5rPdvRsz96zmE81309sTx9gvtQmv/Ge69nwfmZUI709iEYdR+7xL3b2weBJwEMxK54H/r2lPCSZGKukRD+YIG87KiLslqELs98+Hd/bMM3P/a1lPhNF74WMzdR97TNVseR7iNJ1HGb2kNisq0MfaSPytAupkP2v2/xRP36K+oXYz/Eb4gyfiouti2mJxN9Af19KJns//yUVo+Q0yPkNAR/SM7ZLco5W8hhrNj3lRj9yjwu8F411iUt+G+68zXWHfVdmRwZOUuAj8twX2VMTKu41yX6+5GGX08m+26VvTU1ksf14701HCezQ/XJu+C8TJ9UWMscsUL9jj8UV7bfXRIpZ0WLclYIOe3uI5eQnJqjHOwzK0hOn6McxNpKcvod5eBYeBbJSYUOmV5vnj3Og2MtxmnktXdA1Yj+V+FDfnfl5+aDKgdgeRy/uB4s7x7KFweIfySJO3AtMiGsZra7l2zXC2UxtjP6Hwfb3U+2Q724b6OdalSGeVsflbGtsA5WlkAd8Br7HPKz3ZCPx6sppMNIEnX0xfQNxK8nLfnH4fFqCsnDumcH581Tq8mrmbxBIU+1w3CibYryOd9WcTalMuyPA1SmcnMVg2yup3y5TrK5Pfka+x3zK6yyc9Af95mDLm1jvrY01v8Nf7BAXnaofdIxc9DfXj79wpdW/NFnU+I3Xfga+5nKo+qCvsU53hI1B+V5Jtcdy9Q8UM1BK64nLImxH+Krvslz0Ni2iJmDhspwfOGxZ0DobmUYozgXsJilxk/ErRH9f4fx86M0Jqs4ehxcY9+cJuj5viDWB+PstAis3oDsIUE/LSAb9UJell00Hqj+YbZp8TmfPvWcz1QkANyidkL6GFupdmoQPdpGjYO9VIb1n0plWAceI9V6q/LPXlGPFK7xc0Sp0FXloiqPC/meym8GiCY7VP+fQmXIx3ED+z/HDfRRjhvYthw3rD2xrZCe5xBG/3s03qOPtDqH4P3jON4o/+a5gdF/BmLbHxTEtr6SmB8vWFNLEp3PtxgLaioWYH/nWBCKwdlRNm5yv8W2OY6wjhNYaFN+Ptls0y/oEa9G9P8vtAG/AQHrN0i6YxtMobLYvNz6Q0b/r7keas6Gc93Pke9hTFPzE/Y9o/8P8Ocv0lzXI270UxnGAb7vpcYc5WcNwY9jKPNZHLC4gr7Yjrmu4deTyXWuMtdV/Q/HB87PK8bNw3PdhpCn2gHnumhTlG9YnMsfqbiGdoqJa0hvsaWRTK4j92eMERwH1Dio1iJZnrrXjzEiFCNTgatyFlxffDP1f+xf3P+xj3P/R3/nvAFtyHnDEOiich4cs5G+5/hxvtnHT8RUvhzKY4cFPe7HGqD6oK8PR2BNCcieLuiHA7JRL+Rl2UV9UvVFs0075huYF3BfVO2E9DG2Uu3UIHq0Tdm+O0RlWAfu12pPmfLPUJ6fHdx3B4SumA+Yb6wBOv6OA+ZMS5KJ+qj3KCA93/vekP/uL6Dn97sY/cm5HdSbIPEdGKcXyEP91LtfGoJ/QwEWxhus36YC3ReB7l+NeDeN+tyN0W8W9PhuC9NH2WZzomUXvX9mJ9XH6JeK+qjYYD7VYmyYerTfOcLvFcF3jvDb7PF9TRupDPtOzPdN8B0y3K/R74w3s8Ol+cY89SWITuzXKyL79ZUF8lC/UL9G/rL9+s0Ful9Zsl9fKfTrpH59TWS/Np/q9uvm/Xqt0CG2XxtvZoclMybivh7KlM9yGxv99oDPvkHouhWusX1vEfRvABr22ddD2S1Uhnw3UNktUHYT6XBrMtkOSM991+hvATsM5/eDlK+bXi36+hTl67cCAfv6DijrFfTcFrcJ+h1AYzZpED23C/5GLGxr9nGzUX+i28DwakT/FhH7TT98x9utpPtNJXWP7W/Yp76SJ/3mg1uBbi3JvCkgk3mzv5vz3/0F9IZXI/rdwl4pycB+gHrx+Gv0bw/Eg5uTyfXCLyKxDyrb3yzqpWz6eirDNjZfUP3T6NoxFmH9uX+G6podbBsVW9F3rf0byeR4uJXKsG/cTHK2Cjmx/o8+9MnhibjXQ5nh4vv1rs3Pa0T/TMC/1HsfVQ4Xqpt6F+QQ6YC8Q4JvPZWhX/J7A28SdkB63gdt9C9EjjemV4v+vEr5M8YD9mfV15G+bF9nn0Vfv56wVJ6Gbc3jjdmoP9FtYHg1ov/xwHiD+fFNpPvGkrqrN27zVwC4T51N4w3m92tI5saATObN/izn7S+gNzx+z+z7A+ONmjOhneYRptH/fCAeqPw+NGdqlt+H3pV6PZWh7vglHMNmzBb755VH+526/N5cjIc898G+wXNNNQ+P9X/0oXnDGrdovLkmP2f/+vWSc3Kcn5Wdk/N4o+bkyr+uojK0Kcc6Ne4iPa85Gv3vRo43Tv48Q/kz+iz7c8g/s6Ps2G82aSSTx4Oi9R7EwrbmNlDvJN8s8Hk95Y8D481VwH896b6upO5V+tv38psfap2Qx5t1AZnMi/GiaLwxvBrR/0VgvMG1ELW+yOON0X82EA/UGmdovFG2Xy/qpWy6gcpQd/MF1T+NrsX+ObOTvzS1lsqwb6wnOWo9Ldb/0Ye+3piIy+vviIV+EfJH7Dcn5ufsj38f8MdQP8sOtnmzNXrTR/kjz3lQ95A/Ot3T2ab8EevP/hiqa3aU7avWno1ksq+G/DHmvg3GEPZH9CO8b/PZxkQ6vAeY5v9t78xSuF7C5tGfbDH8OulSUt7h/UhLSR7Xz9qu3Hfc+Y4VWgVR8VqaTKw9lvXStV6iW0u/q3zH/QwoU5bgEQTrdEYBH9oiEdd6BP1Swloq+Ez33gA/YiAfe0xK1zFqzhOya0Q/LX+lShY1vryoWO68ZLId5tHvNwl5bex104+NXjdMqEaDtHgMg2ZIz7+5RdcLPj4Mp0Y6n5h7UeZ9c/Jza/n5wHtWMrHsVCiz53UyjE2EwZ8dU/9Rd7zG45dHpFD3J28nPvxq4JYIHc4QOjcEv9ENCr6qtmkEdDY56C+4nn3anHGe7O9sKFORiO+fGv2Pgg8tzc/NlthjTUdl523JRF3K2nmbkNNuO28jOWc7ykEsvlemvlmGdrZ2MjufA2XLiG85lCEdjnL4zojlQrbCN4xmPnjpHF23Ih80WTWifwf44OXkg2o05dE3ScI+z37ZX0B/Ouln9KthtOZ5/DxRZ9SL71Ma/VrA/GoBZpKEY2WoXuhT8wrqtV7US8VY41djy5lUhmOLxXAcW2qEcV1+fSCZ3B4lsgT5zFOR3khncpdUkxs9BzH8ejLZhlWyoSUkj+tXLRtC67NVEBWvpcnE2mNZsznIJvpdZQ6iosB8gWkRReX1zMe9kK/1CHp+e5LqQRydFT9iIB97jOLLfp8oeGJ6QMX8vDe2Bxi+Vw9o1u78RqClQpeGKEPdsQzlLBVyFNaphHVqpM4tfoSVfy8pUKNH8CfEy12bE/v5okrYddYVyC4ahA2vRvT3iMEqxJ8dMW6PTdSOwG/4Xm4f60I8iUPe0CCfJpPb8Ai5anZsKlBDjSgJYaXiWnaoXPJoufGjgZyrR/BnudMVtLbfLM/muZ7RPx7IOdXcIPTchvqcNM5HTJ8h0gF5hwQfzzNxn/LZpMP5yWQ7ID3vlTX6Z8EOoXvJplc79sqeDwR8b0B91xfpuS0uEvR4n8hs0iB6bhf8jVjY1twPzEb9iW4D/vy70b830A9wnn4+6X52Sd1VH+Z5LfepS2kOijJ5KD0nIFP5rMkpihtFc+SfCMxB1doP6sVzUKP/6UA8CK1TZAf7oIofy0S9lE2XUxmuSeB6kGEzZjv2ymL9uX+G6podVWOlejbjbCrDvsH+f7aQE+v/6EO8tvhOoDPcHoFr9GP5b/NxpjHeGtH/L/DHL1BMQF3fSfUYA13S/L+ld4+T7iNJ1BGd3hl+nXQpKe9wevc4yeP6VZvXs0eiVRAVr6XJxNpjWbMsbg39rjKvfwLKlCV4Xo91eqKAjz2Xr/UI+scJ63HBZ7r3BvgRA/nYY7gXYVR/p5DNvej3A/cWUe47k2SSHbgnrRHyrNc9QbTZYb3uSarTSBJ13Bjb6wy/TrpU7XVPkjyuX7Veh56CUrYTqtEgLR7bQTOk59/celcJPj4Mp0Y6fxHW5P+E8iH02JNIb9QhFL8agt/olJyTW5RzspBjnox5A98r3SPqamUPgTx+j/LDwDeXyh4R9bKyRwOYjwUw3yHKsra7/YSJdBiN0oL/2dErrrFNHxe6WtthBMAlj6Le9mRADvIb3aDga7U+SmeVY+A9sK9TrrQXytRoYLtuakT/24vG+b5J/W0v8JuOys7cF8va+SQhp9125j71lKMcxOL7sPsIi+1s7WR2fhrK9hHfM1CGdJgR7IPrzwjZCt8wmvng9+bouhX5oMmqEf37wQfTEybWP9YHn6Kyp6CMx0PTA+2A9LwP2/TsL6AvqtdAXhe11vC44Fe6n066PBXQPTtC72Exunb6PMps5j/TTxjnQTsU+c/m/LxG9M+D/8wi/8EMrR31D/VrzOR41qD6nYofzId99DUROuwTOjcEv9ENCr5WfUPp3Mw3TiHfeAbKlG/wc7NG/yD4xmLyDYyfpqOyM+eAZe18spDTbjtzfvesoxzE4vFtP2Gxna2dzM7PQdl+4jsAZUiH49t+uH5AyFb4sePbBSfouhX5oMmqEf0bwAcvJh9E/pAPPktlaFOMvdw+oTZISe/+AvpnqV5Gv1KMb6H++ixgciw3+tWAyWvDJhfrpWbLIV98TtRL2XR/0lw22nldgez+RNe/yFfWB2xq/H0F9WGbGv3GgE2VjUI2VX1sv6jXkKjzAcJSK21o5xibYv2foPob/Q2BPOwpwa9yB84hVR6G9Px8r+pjKjfhPva6yByScxtcW+C9cri2sJfKHoIynovh2sLTVIZrC2NU9iiU8fiHawvPUBmuLaDv29pCjep6R369xTV4uafvcdKtBvRpwf8kiRtP+f4RymnHuomS84SjHMRak/9XczbepVR23QD5Q3PDPS3K2SPkMJbF5OzAnMj6U43o90C/nrl4IubeZLJ+e+DaukBduT8jlrWZ9Q+Mfe24R2X4ddKlpLw0FHOxfnyn4GmhS0OUFbUpyjlVyCmr19Rk/F25+Sr+mp23PXDHhl13JHTU6PdVBSryZtF1BaqlAjelP77OD3z1ClrEPlJd72jKOa1FOacJOe1e6jyN5IwBH053XqTpTrMlZdsyx0vKr100zve+wHSnqNuhr+GtDvZtk1d0u/+hAv1+DELvFygdfkjUeVNA570gg+Vm52cV6PCTlKpUDMUyVeGlUNSnRmWoN7YNliXJuC3wGvvcmJDDWEXDpNmVU7oPlBwm0bd5mESd9lIZDk1sByVHhXdlh5CcJS3KWSLkhIb9qrFE6cxTiezAWPIRiiVPQZlKaXirmNFfDLHklwOxBHXk3youF42TRbHkyQL9fiMQS1RquD6gM04BWa6KJUb/2xRL+FbQSBJ3qFjCtyZQnzNI/7JjIfIfqbGQH/Ns920/tdw/BudYZnL4Wii+8DS8qD9+MuJWi1oW4FstKfTHP40Y22Nu1bU79jJW7Bhk9J9xHIOejNCvlkzuU9n5UqhzEVYirhk9xhWeBzxFtHsDtEVxKzu31622+xajbb1V/ets0q9s/0L+2P71tZL969b8nPvXNxaO832D+hfeDmC78i0ApB0g2meg3rG4fcSbnc8l2n2Eiz65OplYX8PdPncc/59oy9AzhK/+Z0eM76De7Du4RI1bwLHM5PA1loP8Rqf6AvrOf5ygZaLvYPvemp/zMv+VYMvvnVBcR15m9bCzXX8OrrNcvgW5n2hxKZ+XiZ8jXvW/mY4NIWc/4R4I6M+36Z8RfO283Yr6DiZaf/U/Vg5i8Wsqinx3eO44LtqhyHdtoatG9HPAd2fm52o7DPsuxlTeQqmW/zL8h0nng0BndtoueI3+eaJHjOzgucW78t9FcwvjrRH9/FxPnFtY3Q4IeVndTi6oG7YH3oZ7nmQb/Qpoj1FqD7SXtcdQMtk23AfeBbow7UCibXA66HHq3GJZ3C9UHTOMM+YW0w0IOsboETYwDBUXjG9IyOO+e5BkHAjI2C/4lAyOx2izd4F8840XmpS/S9QtEdd6BP3BgvomQvbzTXAPCBwV35+nsmdFGccurK/aisUxkePecKC/FPUJ5VcHA7q/i3Q/KHQ/ENBd2Q/jRyhvsN8xY30qfpt+t8E1jrHqVj/SGC/f6r9GxEzGLNqScmsB5msBk7dPKJ/BRyD5VlGonVCfoaS4nyvdMZbwtVAukwgdMBYqny3K49geSge1/UbFTd5+o/Lw2L6J+fR/HKNzjFvmapll5xifhvnpbRGxopPnGLxm3glzjL2E051jJMlupznGB8F3315xjsFbqZrNMazM7Nsj+PjxAZP3k5D7PkZ4e0AW+k12PhfO0Rdrgj875/sKRv84jHvHLz50PiT4LyR5uEam7vWwT1wo9CqqpxrD2G7/Ldd7IJncF0vcD1kV8n/DPlARO6b/qD6v5g91UVaL0OWef9lx7o7+hz7G/cp04WsxuYx6zbrZiufNI0nUcdkgyEhItpWhbx+gsj4oMx0yn+5bPFG/gxX1i7Ef4jdE2V1wXqYtFNbTjlh7K2JNTyb6KPZDlaPx2o1aZ87a8TcpbmMcOp90LRuHkL9MHOL7Nkb76xSH+PG6kSTqOC+Unxj2/orYsXGoKCdAveqiLCYO3fndVff+zvV/dlKaTI63veJazJZ09dqiFvv5OSoOcazBOLSfyjAOmQ4qDlUcU86JsR/iq7UkjkOxbaGwnnbE2lsRy+JQ6N4CxiHO79QjthiH+H7WS5Cz/RatNYbWqlX+pnJMLtsnMDPZ/7sg/+zP/+MjQHw/UM3R7TdeQ19HHr6PbvSfANt8nPTjfXVzhX6qvXCPzSfnFtM9E6AL5ffqPngo949tF/XI0Vgy0QbqcW28Ftr7YHQ8Jn0J2uAvA2PpxaRL2bEU+Y2OH51Q/eBJoUOz+eGHTpxI1641HbNvto07//qQbeO+eufuLXfuuG/n7Vt2vum+nbt7SYMx+s296jnSSB2mJe/GeAf93ku/n6bf+wROM5lqpw6+LIzlxuzUOVfofDTlXNSinIuEnMFEt4n6b3L4Wmg35kUkp2h3yj/SCkpod0p2XJf/590pfzk6zvcdih5joFfIzpcmE3Upa+dLu3LaKueyFuVcJuS0ux9cRvXBkZntVnY3GPI/fYTlNOvXwydqmWX79f7Rcb6ZJ06s4xjotTeijmNwjXc/7hV1NKx9TbCuIyz1Ag21U25vhJzQyxv2RsqJqU9IztGsj2GpO1HYBlsCevEd3+eaYPGHo9XD8aGXJKQCU8kJvSRjLCDn2RblPBsp50jVh3fq4IyNY5dqu+cCOiA/r/K1667apSSnKEZeSDFS7QIIPYli9A+NjvNdEoiR7LuvNju3624gv3SwqD3XUnuqu4Gh9jT626A910W0p7LNWKA++KRPTDyMeXnJswF6tQqqxgGzL969sTZq8U5N9CcaDb9OupSUd/jBcLVTDeuHD2DPys/zmfuqnfcvW37Rmu9P2/fcu5ttarjDKDSZuBsN6RP6zXyZbvxk5HNCRnaw/+wnOm53u874MTo1o21WrvrNQaJFX48Z15B/rADL+nx24JM8vKvV6G/O+7l6kkflUWpXb2gM537HdL2iDlMK+N6WaP2wzusCdTb62wJ1frZJnTnnVvme2o3Gd7q4DgPJZB9AjJj8BVfm8KX2WIb6hVZOlws57V5NXE5yisa7XTTeqZ1buHJ7X37Oq++bR8f57guMd0eq/s36NNaFfQrrVfQE+1lQjvQP53VvcXeIfFqWc7I9Qv+sfo9Sm6q6h9rU6FdBm74zok1D/WMMrvG4puLE0wF6leuoNaP27bBJvxTjo4iv7l5XyUXUrhh1Z7JsLmK4X4QKof7NchHmU7nIMwUyivoe5wecyzTLRZRORbSt5CK8mxh9PSYXQX6jM//cS/qPJFHHiOnyNOihdg0Vrff0JJP7oqIfI/0Yn9sWd7Mo22yFcqR/D+QZc2m3IOpwcYF+SRLXFshvdIOCLy34b3L4WuhuKt+JbMc6dnaE3hpwJ5xjmckpiskNwR9ax97fopzQDpBmvn5vft4sJ3o/jZ+cGyMvyuXc+Fsj43w/T+Mn8psvhNbE1d1t3k2Ad7f5rvhTQh7e3VZ68a6JsnfplT78Bp7fOXFcl4+QLljXjaRL2bcHIT/vtOB73tlh8bcPrpeIv9EvsTP8ejK5zlXygz6SV2QXlUMar3prGb6cs0jORiEn5DtKL8eX2JmKZxDdugLVUoGb0h9fP4OuqRQDsTOdfv/kcTlohpdo6jBGuCNJ3KGmDhxiil4CVKVrIX/Ri7lwuA+9yAbrXPT9NdRrLKAX8o8VYNUKdOfpndH/FbVRxfTsWt7kZRiIXXFD77WxoafoXfGoV12UxWy6/Vp9xcf/7pd+7JM8hJoufI3DhZpCrhP0Zit+AHQkiTo2qk23uESRHegX+6gMhwfTQW26faaifjH2Q3x1224Azsu0RUOUrauIZRtl1VTiaMWkouVdfle20f9tYKlzTOj3JFwLvSxwjPjGhO7ZwTEnO0YSffwnHYZn9j9OyMKpGdL+A9R7/uKJuqoNrHbeG5CRiGtpUmwblqFeJPXWZKJuT0fopraMIEatQM/supresN+Wnd48KfRRcta3KGe9kBMak/i/yeFroW0n60lO0fQrnTfOg/GkaPp1T37O068vjozz1XJMNc3haSS2gcpZOAYaf9ELWDieHB5bc53UywTUCy3vAcwiP6sJudn5WQU6DOU6tJhzyJyTl37QDhxbs+O1ia4TxuktQMM2ULewtgbo1bJz6D3o6psljFV0+4xl728im2+NFX1nBn+j7OsCsg82kc3bsNRDhvxgyuKTx3WYR/23D3hUu28gTKOfe9I45sklMTcWYJ49bxxzlGIC9p2VyUR5ZfMP5O8uN5RfbuCcQMlZKeSkyWR/PsLLDXOIznO5YQ5dK7PcMJRMdrGbCuqQADZeYzdHfqNTck5sUc6JQk4I6yaBZfSPCPoTBX0bXGM+0W0NqMa4zVxjPl0rcg07eklmdj5G/Nw0rOOQwNgTqFOvuMZNvUfIUnJublHOzUIO38zfStkRyi8RLZ+26IdfQebI/1hF7NjIb/iDQp7pVRdlMas9S3/z0Z++dOGdm1PiN134GnfJMUF/s6BvcdXtSbXaY7LVas9jVIb9wHRQqz1jFfWLsR/iN0QZr/bEtkVDlK2riGWrPfhlrlBfPlIxox1yQlhqBcjozTb9gl7FJKO/BWaN9sW23qTY3om41pNMjkc35P+HBNYlBbor2YafHQ3Bb3RtjIl9ZWNiPZlc5yrZsOofyi68oQB51QaBuXCOZShnTMh5JWGZbw4mk/03Lfhvcvga2/kxR6wxRyyPjR7qFWOXwzmWGRZf43ZBfv6y2SNCjhqHHqUytNs6KsPx/CyqF/ZJjt9l49AeoZ+aleNq5N55WiauzKk7Fxy3f3H+ON++ecV15Jmv+mwL0vPKntEfoNy1HZ9taWa750vYLju2UF2M/r1gu3cHbMdjP/aJx6hMfTJFbUQv+vRBksTdPUP+ojuuVp4dLd4xjB77DF/d4a0y9qk7tirGtHjHtmby1CZg1Q7DibZp0deSs0PFOo5nGOv41f1jUPY0lWH/PhPOi+KZuvs6FNDvSMVNJWdZi3KWCTmhPDHG15UcpXOzWPZhimWPQZkaB+7Pz2tE/wTEso8E7kqhjvw7Zn5h8mI/OWb0vxq4K6XqfH9A5zGQkSST+03RLpvfpLGL78iNJHGHGrsMK5TPtSg3ejXe8OvJ5LhRJQY/SfK4fri0OSM/z5c2N+zacfvqHffe/8DdO/mFyNhibBVExWtpMrH2WNZL1x4iumvo9zrBlwhsXPHEzFpZIubDWWr/wmNCrl3rEfRPEtaTgs907w3wI4ZaCTIMxZf9/kHB06kzGvVCLu6ZFbPZmbE9k/e/VfyA6uGeqfZnqOwotBdP7e3Cj69iGcqJ2duVnfc5Ys3tYnWxulhdrKOApWZhvIqF4xTvtcE4yDOnsjeu1X4HJWd9i3LWCzmDgi8t+G9y+BrLUTqr1Ra2W9kVSOTnl58WzdDq87XM2Bma0e+GGdrg/Ik6qxlakujZMLaDYTDvAOhgZSXyi6FslvbyonE5bFce00N5SHZuewzV/s09VIbYsW00h9qoD8pUG/HeTqN/A7TRifm52scVs49IyUupzv0F9H2kn9EvyHXCu3Shvd8sD+2Bdr6mQN5CkPdV8AerZ0KyW/S7mcrvcM8V+51aCVKPDobihepbapWV78yqvXvoB7xyYvz9iW4DfKYJ6c8SbR7r59yuRr8ssl3Nlu1oV7QVt6u6663GqZAfYHvxCiy2OT+C2GyPH7er8Rf1ZX5E1ehXBNrV+Iv2pnO7Gv0Vke1qtmxHu6KtuF0fhjJl25hNddhePHZgm7+DysagrEZyVPxWe7ZDba5yMm7z14o2Vyv4MZsRi/adzszP8xW4Lbt33bczX4JL6AgtmWW/nyxQY4bgT4g3pWszqEyFz9AmIZPdn+glKw6fRn+9MHko/GZHzJZqbO52LOIavteW6tity1b3UDfDsg5w1ey4pkCNVPAnhJWKa0nSfJszZ4EhEytTqb1aoZHD6G8LjBxqJFQzIqNXmTuOjqaPqj8/SYZ8YwVyYkc0o78rckRzmvnIEQ1tFLOaGXrJlLqfjasN3NXw3jJnp2hjftqsWTfkT48qP1UzK+UvoYw7ZB/lX2pfg9pbEZoFG107ZsFYH/aFUNtmR8wLyrC9OWvFvQW88oS6FD0hh3JifQFXO3gl5LFIXKMfAyw1hPOs3OifFjHAMNUdubIzQIzjvJ8H+9hTVIZ8uK/AsBOia9Efp3muymRH1b4aeom3mmEVreKgvXEvxJHag8XjN35uSY3H/EImo/9xWDX6EPWRZp+AjnkJIfZ7jpcYL56LwHo0IHu/oH8uILvoU94sm/XEzz+bLCsz27TYV/pUX8H4zH0lFIuzo8yLrlVfwadr+eXcsfvB+G0cY1AW2g+GTzCzf6p8MXZswH2Xz1PfbfeqPefEvwxjBL9Fo9ne2nsKMH8tMO6oOoTGnWYr5Ny3MPZxnq1WJVXs47io4rWKIxwX1UtrkZ73Wxn9S7n9bMrcjpfWcuyuJTr34j3ARv9ZiN3/z3yN2VcS8w8j5yxOsa7W7ljXbEzifarYNkX7DREr9CYgs1F/oudLhsd32/48sNKG8ZZjKsZbjqljQm7oWYPM7v+W69Hsc4CfL5hnoe8hL/ue0X8X/PlLdAfLI27spTL1qVHuP0kS9jN1VzDmhd4t7vmO3tNu+PVkcp2rLMXFvpi6xbh5eE+7ylVUO+CedrWPHbEsVh3puBZai2lmV34+COvI/RljBMeBmJxMySvKyf6tTTnZXsrJsH9x/8c+zv1fvQBfzQE4b3gOdFE5D47ZSN970jjf8SdNxFS+HFpjUR+YwVyc5/To6wcisEJrfQcF/YGAbNSLP3RzgH6rPqn6otmmHfMpzAu4L4bmktkRYyvVTupDK/xp8Ni+y/OwMSjjfo2+jW9lYv9stubCffcpoSvmA2rd/YZkosyyu7qQP7R77Ei/XuUGgWX06s7xEXq9ykKi2xpQjXFT+uPrC+lar6DF40htJmQsDOFPAhZ/DxHvDIbs1CuusV7I/3ABVtHtNZ6SGv0VeXdt8dUrL7bxNQMvpoSXJDotbeerV37t566b9me/c1HUq0Oyg7urWpbfKujNVhUfhHhXaLm97KtXTAf16pW9FfWLsR/it/vVK9dXxIp59Uq7Y5L1ZUtp1uR9GZf8jrQulgqs6wBdLF3a1AG6WCqzRegSGg9wCZXHFtT9YSp7OFCvsuPOnkg521qUs03IGRR8acF/k8PXWI7SudmG6lsprX0EytQS+pvzc968OgNe4PmmHFM9llw0vqdJOO9g/fCxZKR5skC/O8E/+bFkVec3B3TGpciEMLJzzkmM/q2Uk1TMG+QyOecIbchXone0Ha3XIpV7LJm3eaNVEBWvpcnE2mNZL13jjWtr6XeVx5KxZyhL8GPJWKcnC/jQFom41iPoHyOsxwSf6d4b4EcMdXPUMBRf9vtNgsfzhQ/8ZSQPrL0Cq8XsOPrLxoZfJ12q9szQJpvs4Lo/LXRRNwViNriEXk+vbjB4YD3niHXAEWvMEWtuF6uLdQxjqY1tPGvH5yVuz8+P5uO/W1qUs0XIaffjv/yZgDEoY7uNJZPrMxaQo76O2Gwm9JGTtMzYmZDR98JM6JdPmqizmgkliZ51hjY+G12LN3umHpdMvtmDduVxWK32YbvtzM/VzZTQ47+xbfQ71EZq1bom9OFnhb4BNx5fotkq8mM/L+pXSl5KdS77+O/HYbYaevz30QJ5aA/UeX2BvD8GeUfg8d/pZR//bbaCFPNCcNW31A1Bfpww9CI89Wwb2jvmcUKsKz/bZvSfEf6gxqJahH7Kbs6PEz5WoMaw4E+IN6VrwwVYhpNdw+lrzOOE6olhDhFfFiYPNVl2dB8nfMU9Tri2QI1U8CeElYprSdL8cUIeVco+Tlj1QfRvCZcORdgxuBZz3w+bN/Q4IW8tRL5HC+TgiIb24hHN6P81ckRzyqTkiIY24jaMXTkx+mbbyrmrqdWU0MwmthvGPk7ImZryl1Ye32L/GoOy0ONboaza6NqRVXfq41vqvniaTO7/ZX1hDOr6kYJ7TEW4fM9HPdaBQ/g9+Tnfbzk+j8HqsQ61Ah3yR+W/atU79Ep29dplvB9o2IzZoj9OUf6I9Y+Z5YX2gMT2VfWyHd6Oi2MBp5HN/Cbkj3iP71aa8aGuG0jm3kDdsoNXHpCf2x3lnNiinBOFnBDWBoEVar82b7kzFecR3daAaoyb0h9fn0fXegUtHqqZHinQO0nimgn5Q+6wp0U5eyLlXN+inOuFHN4KsiEPuy1uqXoi5j2+Bytip4SXJHo2ZfiDQh7fTMOymK13f9/Y+tLd337//0iJ33Tha9xtnxf01wt6s9W7gL+Erd6phiaTrbbeHaQyHF5MB7X17vmK+sXYD/HVznLeehfbFg1RtqUilm29w+HxSMcM3np3HaRQvMXsSOliW++2dYAutvXu5qOoi5KzpUU5W4Qcz3eyNwI6N1v0f/PJ4zzYP2IX/Y3+j0bG+e6i5Rll5zTR41f235ZwkmSy7flJVqZ5skC/e8CneIvak6LOOwM6q68+4bLTWQU63E9j99NU95Ek7gh99Ul9M4H7idrohNdC/eTJgJztLcrZLuR4bhJqBHRup5zssD6n7PY6OK9iN+QPtc8jLcp5RMjpFXJwc1gbvxdRi2kXxO/070Xw0nUr71v3/PYEb8xSfvM6gVXWXo5TYFNxG9FtKVCtV+Cm9MfXt9G1oimwYR/N0NyOrt8stfjxk7XMotSCX0Jh9H+3YJzvJyi1QL2uSCbKK/sBYeQPfah4e4tytkfK6WtRTp+QE8K6QmAZvXqYvk/QO3ZhU/EMoiv6VnMqcJt14TPoWlEXtt9H0x2ubFHOlZFyXq3ufaXA6rr3BOyjuctye4tytgs5aksJTribjWC/m482NiLZxO57sAvxJTjnfQk4uj2eTCxDnZ4gfXjLT3ZYsszPdI0kUUf0FhfDr5MuJeUdTpbV3gesX7Xni4qeTkwJFa+FPJ93snAv6yO+Ks8XqaD0kMBUOzceKeBDWyTiWo+gf5iwip767C2QF9ovqDwmpeuY/71TyK4R/V/A0s3XF43TF8kq88kBpina3fO5wPIRvkVB1Yt78yP0GyPBQIH8b0GU+dLJWn4i5HP9cETpL9D3YdLB6P8abMCb9tSnQJKCa2gD5C36jbQ8cONv5YvvJHr+8G4zHzT6vwu0/x6hA8afsh//7SnQ4R+EDiJqrt51756C/Xoc1fg3txK3xB6BU3SYNTKPNe9l63DvYDn2W3lAVvNZ+fnhVOzunbuL9iryiFArkNmT6GOwQLfsGEhaGiujx2bDryfa80aSqCPl6GnyuH6h7afGq/aWFPXSZnJa3H5aNGirYMH8CfGm4lqSY35q6NC52o7EiUm7vua+vUU524UcxipaqHljfs4DxHH5Qo3aEvYo6MGY2cELc2OiPttFfYxeLWiNiTqGHt4OyVYPghv93pK6NtvSNUa6on4x2whR1+uOsK6hN9are50tPpwdHTqP1sPZ5aY16LFsFUTFa2kysfZYxhGSB9ur6XeVaY1a3d8rMNX7c58u4GPP5ms9gv4pwnpK8JnuvQF+xEA+9hjFl/3eLXja8QX2px2x9gmsFt8LPDu2Z/J7gfdVkxd8L7C602V13y90Ud8b4Dtq6t2c+4UchfWMI9ZzjlgHHLEec8Sa28XqYnWxuliRWKF3hauHuG7Pz9XsgGd0ZV8cifyPBeSsalHOKiFnUPClBf9NDl9jOUpn9f5ztlvZHSjIv4/qg0uoeMPmtgVaZtHDTbyb0eg/B1sOdi4oriO/CLVX6NziA0aD6gEjzHF4lUP1H8zh3p6fq/7TR2XY1vi9qVAb7KI2wG+TqTYwfXi58yVog/uoDdS7yUP9RsljHyl6hv0x0s/o3w6rHfwaCfVkSsgn0c4PFsh7WKyutPHBttnK70LfbYzNu2P91Gyi/JRXbNSttdBnkI2/6DPIhsdbkZ4SbR7r59yuRv9MZLs6xZPZZR9YVCtroQcWlR+orWiNZHKbx3znKPQ+CtWu6lYTt+t7Au2qXmCKenK7Gv0PRbar2bId7Yq2imlXtd8mNH6rXb9qBym/5LXZS0dj2lW98pLb9acD7apWuUNx2Oh/tgPiMNoqpl1D36ts1q4ch7Fd+XU+ONZxXz5SMfrDos1Vzh+zZ6zoRbiOr/N5qkCNWYI/Id6Urs0qwDKc7NoYXIvZGTAGNGxyo/8VYXLVTVEfFaKsPkfrXcoVv2MRfJeyCqn8NjjVzbCs7LDYBlfNjqsL1EgFf0JYqbiGZV6vH/hd2oKnvkQYinwq8zd6y0CLsgvDqxH9xwOjUCgLzg6O1up5V8yMecct1uEglSHf3gI5ODpi5OfR0eg/FTk6mux2jI5oIx4dn4eyXkHP9n6XoMdnqXlVCZ8D5y6NNj5IcpqFDvZ/5adq9q2y8dCrWJrNykJfvNtPZWo2p3zB6NqxUoL1YV8I9aXsiHknALYjz2xCfoL9cj/JCcWl7Aj5Aq4u3EarJlgfXp1TW3TwWmh1zsqUnEdalBOz+S92n4rRf7sgRrEuacF/052vse6o71hyZOQ8BHxchuOp6cFjfnYMJJNtWaIfRj+Xafh10qWkvMPpV43kcf04/eoTuqinS+6CcyxDOaFHExDrMUesUL+7hOSU7XeXRMpZ0aKcFUJOu/vIJSSn5igH+8wKktPnKAextpKcfkc5/UBzFslJhQ6ZXieOjPNkf8dBWa/g5a9wG/1bR8b5TsrPzQdRd9QR+Tl+cT1Y3ikjh/5b/Bsg/ry46aHez2BYzWy3aCSZUJdeKIuxndFfOzLOd1p+PkT8qm+jnWpUdhyU8aNcbCusg5UlUAe8xj6H/Gw35OPxagrpMJJEHdFfMDf8etKSfxwer6aQPKx7dphdrH5Tq8k7/AXzQSFPtQN+wRxtivINi8dNztGwDPvjAJXhuHYclWH/PjM/V75cJ9ncnnyN/Y75FRbW4SyhV43orR+aPfmBlZEk6ljaxnxtaaz/G/5ggbzsUG/GrkXo8tvLp1/40oo/+mxK/KYLX2M/U3lUXdCbrfpJ95Ek6lii5q8mm/sE2yxJJvq56aDe19ZXUb8Y+yG+6pu8Iye2LaYnyaT4HRpfuAzHFx57BoTuVoYxinMBi1lq/ETcGtFvHxnne8vIREwVR4+Da+yb0wT9INFgfTDOTovA6g3IHhL00wKyUS/kZdlF44HqH2abFtd3+tT6zlQkANyidkL6GFupdmoQPdpGjYO9VIb1n0pl6mFQNQ5OgTqzf/aKeqRwjdePUqGrykVVHhfyPZXf8Lsgs0P1/ylUhnwcN7D/c9xAH+W4gW3LccPaE9sK6XkOYfQPjhz6b3EcfaTVOcQQ6YjjjfJvnhsY/cGRQ/8zezw8ojH7SmI+luM0W/e3dmwxFtRULMD+zrEgFIOzo2zc5H6LbXMcYR0nsNCmfBvWbNMv6BGvRvTPjBz6r+58Y/0GSXdsgylUFpuXW3/I6D84cuhczdlwrvuukYn1xpim5ifse0b/oZFxvhfzc8+40U9lGAcQg30q5GcNwY9jKPNZHLC4gr7Yjrmu4deTyXWuMtdV/Q/HB87PK8bNw3PdhpCn2gHnumhTlG9YnMsfqbiGdoqJa0hvsaWRTK4j92eMERwH1Dio1iJZHsYIzMUtRoRiZCpwVc6C64u29qj6OPd/7OPc/9HfOW9AG3LeMAS6qJwHx2yk/+jION/HRiZiKl8O5bHDgr4BNANUH/T14QisKQHZ0wX9cEA26oW8LLuoT6q+aLZpx3wD8wLui6qdkD7GVqqdGkSPtinbd4eoDOvA/Rp9exrUmf0zlOdnB/fdAaGrygfUE7mhdwY8DVi9hJGd35Of14j+T0YO/VfvLdgndAjtnwjtgkd9hkgH5FVPSu/Nz5W/G107Pq10JHf881oy7ovg9+aqJ7ti/Sa0lwzff87vRm/mC5zHPwNYyhd25ec1ov/KyKH/yh9Du+uzg23+nKBHm5s+Q6QD8qr9PNYebdzPM6T8EesT8+QT0rNtDgh69Dn+7Bs+Hf0MlWE/NpmDhIP2znRP502kewb0SQv+m658jecV2I5zSZ9nHeWgT/D9YewvOO/7t5FxHrRXUT+5Nz+vEf3s0XG+7+aYal/as8RvZf+Z82R+tmBxMb/ZUvWRMSpDe2CMKqon0u8qqGff6Liew7meqt+ZXi32u0bZfncQymL63fOCHvfR8VsY1D66UExG/y6Kyf1JOB5yTB6GNuC1lTHgf45031tSdzWeNIsj78+/JzZEOnA8KxoPVFvFvGniOeDpFTreS/TPg9xegcn05hO4vom+wC/rM/qToK1OWawxkwId9hXo3F9Af5B0MPpR4S+hOID+f4AwjX4RYM5cXA7zvgLM0wCTcw3VT0P7Y5vtleb952jHd1EZ6s7j4vMgn2kfIPlYhn7OcpOAvmpMDenL442VXZ7bOmuj5fn5AOGVjNW9oba6U+gb21b7AvVjLOPDvQ8xfQTtcfGoxuwribkC/NnGdJWrnAn4l5NsFSMxVnNcVt/KwDxH5QbPkP5j+e81oj+2L8dOv6TG+jGg4LFe2QbpY+Z82I6cY+N4s5TKVN6VCh3KjqVjUNdHT5yIG3p+IjvfRHo0y/F25Occh7eIdg/ZMGTzZvMaXmfA9jhAZcpnj7Q/hp7hCNU1O2Ken8J5HfujGj+UP3Ke1ey5m5A/Pgt13UW53QGhj4rRrE+znJufB7EY319AzzHf6O8cPfRf5T0vCB3G4Bq31bsF/QtC5yHSAXlZNvZLtMl6qo/R3wP1CcVja5cW517yU/doN/b/kI2yg236oqBHW5lNGkSP9rUyjBsvUBn6Hz/rpvpsbN8w3swOaylW74/ETQWWipM78vMa0T8mfCJNiuPLGFwrOxfmZ+qw/z9PZSpWKV81unb4KtaHfTWUc2YH20bFC+zjHKsxNhygMvRVk6n8az/ofmFELhBq22Zrrxy/VB6pxmGeoz4bkIN6qTc4PBuQc2mLci4Vctq9Bnkp1ee5QH3KroUgP6/xPudYH6WzyXka+HBN9SdHx3nYj3sFL493Rv9ro+N8/z0/j7lXFeu7RWuiag0pO66D+idJO3JOfZ/3SOacnFdiHOd3Fqi3LaPv4dhpNAnp2A57hd5IF4qD2REzf8E+wfcC0Zb8nDX627MkR9kyNg/Be83DJzbXP3RftJl/8Ld9VW6l8gOMuYadEF07cgCsT7vfv8C+gPnBfirD9uecVOWOKl5yGxfljnzPyug/Pnrof2zuGPIbz9xRrfO3MYZ0tN+EcseyfsMxBOM5jtE2fofWyNJk4jipxlxrh2b3NnqgDnZ9ClxHvrdQnTlHYuwfIHqrZ38BveFxLvJl6Cuh9+YozLtJhwNNdNhPOhj93wgdQvbPjlBOOJBM7osl+k30uxUMv55o/xhJoo6U7WfylB9kB/dl1Z+wjOcyKgaqfq6wxhyxQvktv1tB3cfdF5CD/PsCcla0KGeFkKP2ZqQF/00OXwvNJ/ndCgcc5WCf4XcrHHSUg1j8boXnHeXgeHQWySma5/WdMs6D41bRPI+fmTD6jQvH+QZyTDVnRh2RH8f950Q9WN60XIbFP1yrKRGP5HNRhtXMdg2ynbpXE7Kd0Z8DtpsRsB33bZVjDCWT7cE5Pa7P8r1Xtf6L19jn1Br5oODj8QrXgcvMFWP6BuLXk8l1rjJeqXVuzAn5eZP3VJN3+HmT9wp5qh3weRO0Kco3LN4Pq/INFRvfTWU4rvE6PfbvM+EcZRTVib/spPRTeSjmbmq9hX3vSOdK+6vJC+ZKan2obK7E+686NVdCPTlXKrvmivzPBeSsaFHOCiGn3Wu73VwpXk6VXGmtU670qVPG+dbReI+xIiZX2i/qwfI2dUCudC3Zrtn9BLad0X8EbLclYDvu291caVxPvIb43VypOFdS+UY7c6X9TerEuZLST+U72TGSxB0xuRTWr0Tbjcb6puF75VIqL1G5lNXv+WryRjJfm5LzYR77ejhX+5+wvbzaT63NHK3221dNXrD91JqVZ/th3yrTfqpvngvnWIb1CeWVyH+k8spzSU7RGP8OGuPVPa3QngGjfx7G+MdpjFfPxan5Yuj5VqNr8Z5Tbyc/Txh6vpXnfV73rf9xrtY/Bdx7BS/3baQ/IPQwen6Whmn4uRejf0/uU1n7fWGR1rnouZei+7A/BJhH+rkXtDM/R4J8ofuwRtdinxhVfQLrw30itCcvO8ru4WW/x1yWv0bM/Ss71guskK77WtCV2xHbivcbGy36JdaH/dLof174pWp/s3k72j90H17ZNHQfvplNeb0rtBc5dB9exd7Y+/AYQ95xhOeovGbwIujSK3Q13BrR/zqMwX9M47rNl5Ikrs+q+RnOuXg/Es7N3huBFYql7xP07w3IRr2Ql2WznsbXxr4l98nhXJv7lmonpI+xlWqnBtGjbcrOl1+kstj58ruhzn9csLaE9aiyh4bXrFSsCvle7FgVet5E9X+OG2qMU32J4wa2LccNXgdh+rOgHOk/R2uN6CMlfF2uNb6PdHwP6KD8m9cQjf4fIbZ9sSC29ZXE/KvIcdbasR3vdcP+zrEgFIOzo2zc5H6LbRPzbDDalPN6s1G/oEc8frbqm9AG/E4FjEfvId1j1+/4eSV1D+G/9u8uPHSunrfC+fK3yfcwpvUKXvY9o58J+wf+hfINj7jBezsxDnCeqsYc5WcqP8MxlPksDlhcQV9sx5q44deTyXWusm4Vu0bdYtw8vCb+Q0KeagdcE0ebonzDCr2vsp1xDe0UE9fUOnkjmVzH0POHHAcwRnD8OBiQhzECc3GLEaEYGZuz4H3ItdT/sX9x/8c+zv0f/Z3zBrQh5w3vA11UzoNjNtKfCDHsTLKN8uVQHvvDgv6HgOYFqg/6+g9HYL07IPtHBP0PB2SjXsjLsov6pOqLZpt2zDcwL+C+qNoJ6WNspdqpQfRom7J9931UhuM792v07fdCndk/mz0zzX33BaEr5gNHau+f11rBhdB315NtOm2tILTe3l0rGNenWYz1XCuI3YfosVbA/qnuv8WOu7jftxGxVhDyvXatFXDc6KS1ghvztujktYJ7ILbdXBDbyq4VvDHH6a4VHL21grugDXitAONRu9cK9keuFdxbkHOUXSt4Hvz5/vzcM2501wq6awX/BZ7/f7WuFWCMaPdawf42rRX0BdYKuP930lrB+yCG/Xx3rWCS7KI+2V0rKNd3PdYKfr5NawWcD/DeqezYDtfw2w+sr9p3wXkWv7+PaYyXnz34MORZXyD/UHu7srr9UkHdiva+PE+yjf5TECc+SrkO2ovfx4624fdKYfxk2oFE2+A3QY9fX1gsy+4lDwbqmGH81sJiugFBxxjqPce8b+YZwaf2m/He8IMk40BARux7Z54jTLSZGgtfaFL+LlG3RFzrEfQHC+qbCNnPN8E9IHDUeibvW3pWlKXJ5D5l9cXvl3B8wbiA+5Z253s5VX8p6hPKrw4GdOe5n9rbfSCgu7Ifxo8hIZPf/c2+9ayoZyp+m363wTWOsfiekl5BY7z8jNPnRcxkzKL3Ad9agPklseYQ8plz4BqPxaF2Qn3UnreDxIe6Yyzha6p99hIt7+8cEDoV/d4vcIp0eE7gqLi5n/RR7zuM7Zv4Dt9bqG9ifv8U6b6PdEfaonfBFfk3v9NXffsCadi/jf4fA/6tvnGEet1agPmdgH8ru58N19i/m71nk9di1TeOlO4Ye/iaah/2b45HA0Knot/PCJwiHfYJHPPvpwowWSb7Q3bEPkfwtRMOnSv7jpHMZ4RMvMZrSGNC/xrp0J/7j/ouBuqp6ri+ALMOmF8t8Hmsw5ioQ8if0Ub8Hlj1nk3Fh+03IGSN2Ml/hg/Ds75wXFLsg/wulOlgp/mLtS4p69PkGEwm2zmlelZ8n9VISnhJotcIDb+eTLZFlTVCFaOU31v9Kj43uQCfg0M/wufg1F5fbC/1HCKubc+j/qD6GMakW/Jz7mOji8b5Ti7ATJLWYtMnT5iIG+qL2VF2bOF1t9Dzbsj3JJVhmxTlpWhfpN+Rn3MOeTr0zdB3w5y+3fCtV+N7dNlvir4DZXg1oj8P2oDvWz0J/Lzn/qmSusd+nwb7Bvdj9d3M0PvzVb9HvTfl59zvLwuMreodd2NwjX1CjcVY39D3Vnkd6Qg/jyrfgYr14f7iHbv4edTQO5bxeVT8DgzHXvx+6kco9u4V+mDbsn8hVq/Q45r8vEb0mwP+1WxcYRsqf1Q5/1Ay2f9DY4P1feVfRteif81Q/oX1Yf8K9aXsKJvXWtuqtaSnqAxjIb+rcgzK9oLuL5J/qXESea/Nz3mcvDXgLwcCdcyOsmOU6RNaa1FrqqHvsfE883lhB6R/YzLRDkZ/Z2S+4PTu8FXKP3ENtt3fD+G1TlwL5rUg9Yxa6P4Lvm9YtUHR+4bvD+QLOD6F1phjdB8Tuqv+hn3qgsA8n3PW0LdSmBfHnv4C+qL556PCXhzPitZeNxOm0b8zEA/UmPoEXGMfDL1DAvVRNt1PZWre0b58PrnyaL8vw9pf3evl728XvQsdaVFOrP+jD51C/o/j+eMkM5THMi/KKfJ/w2NffU/A/5vNy68iTKP/oZJrXyH/b5YjhHKk0Du4Ld60MT+/6mjn5+z/ofy87DpvrP+jD02nfGsflCmfXZuf14j+50v6F84bquagyodCsZfXZ1Tuyu1YNM7wPMXoPxyZbzl9133m0Y7nfO9N5beh+NmO77r/RuT6DK8tPVVS9zGhu+pv2Ke+N+fQufkgzn15vHkqIJN5sV8XjTeGx2PD7wfGG5ybqfUgHm+M/mMl5+uh8abZfJ3Xg9AuPBah7qH5utG12D9nqf6J9ef+GaprdpRdK7P2V/fG91IZ9g3OZWLXeZrN77+e+39rdn3wphR0MexeQVmj/0bz+bxN6iDf/tci9PjMS9/584+sX/5Wfu4lO6yNprSAP+83dv7JFZ/7+ufahf/M8tr0gzdtvKZd+H9y3N99+w9//453tQv/rweuvarnf+1f0C78H/72pvOfOGHhP7QL/72/d+Y1/3DdN09uhj+Un/dDeS/xHJf/r0FZv8CrEf234V7dP0OMsmssL7tWW1xMlxb8VzqjPnatLuh7Bb3JniLorWwqlGGMRRq0F2LVoRzpe/K6W5sMAI/xN4R83COSFOiN13qIfqqgnyros3r+B8U1rHvZe9zZ0U/8eA1l2/3p7DgumawvtqPpZHYdEPRWhj7B/jIFrvcKrOOI73AbUTtifYy/IeSjLZICvfEat6Py77qgz+wzsHhc56ox5pfOf80l02489Z3timHTXvqVzV/+13tPbRf+03/1n3+x/+G5f98u/Mt+4u3PDJ7/oQ+3C/8Xpv7plf/3Twy8sV34ly4+eMK8j71tsF34fbV5PzLyoVs3NMP//wFvY5zSPIAFAA==","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__transfer","hash":"7413219210146188191","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"2468625083757737193":{"error_kind":"fmtstring","length":22,"item_types":[]},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"12299016439535905117","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+29CZxdxXUmXrf7qdVPavVTaxcS6AkhdjCSWWQMRCCEJBazicWADULIgFlthNc4tCQQICS0sdgmmex2/ontTGKP7UkySezEmXESz2TGmdixMxNnPFmcxIkzXuIkTvz3hXvUX3/9Vb2699VrPdC7v5/U99065zunTp06td66mXvpahR/H3zrA5u3PPTQrff94L9Nd2657gePsiKpVvydWvzNn4+48ZfRNl3UlZWgHc9UQkbmOi+jz3VeRr/rvIya67yMKa7zMgZc52VMdZ2XMeg6L6PuOi9jmuu8jOmu8zKGXOdlzHCdlzHsOi+j4TovY6YrL6OKnBE3OXJmxdO+iL1aPCsjb7brfBnNcZ2XMdd1XsY813kZ813nZSxwnZex0HVexlGu8zIWuc7LWOw6L+No13kZx7jOy1jiOi+j6TovY6nrvIxjXedlLHOdl3Gc67yM5a7zMo53nZdxguu8jBNd52Wc5Dov42TXeRmnuM7LONV1XsZprvMyTnedl/Eq13kZZ7jOy1jhOi9jpeu8jFe7zss403Vexlmu8zLOdp2XcY7rvIxVrvMyXuM6L+Nc13kZr3Wdl3Ge67yM813nZVzgOi/jh1znZax2nZdxoeu8jItc52WscZ2XcbHrvIy1rvMyLnGdl7HOdV7Getd5GRtc52Vc6jov4zLXeRmXu87LuMJ1XsbrXOdlXOk6L+Mq13kZV7vOy7jGlZdRRc61bnLkbHSTI+c6V0HO9SQw39CQbzjINwTkC/b5gnq+4J0vSOcLxvmCbr7gmi+I5guW+YJivuCXL8jli2X5Qla+uJQv/uSLM/niSb64kS8+5IsD+eR9PrmeT37nk9P55LFN7i79wb988jKfXMwn//LJuXzyLJ/cyief8smhfPImn1zJJz/yyYl88iAf3OeD73xwnA9e88FlPvjLB2f54Ckf3OSDj3xwkHfe88513vnNO6d55zHv3K3+wb+8c5R3XvLORd74541z3njmjVve+OSNQx688+CaB788OOXBI6/ceeXLK0fuvLlj5YV+nfNfVrie/TdvXPHS48EiuQ/YSuwHyQZJXDn+0Y8MMmApfvcif84zWI3/euOvV+N/0X3z60bgR10Mt7/4ezfw3k0yjeYXgOYXiMb0rWZvd2Ob+R0ZcuPzaBgOdJtWDXsW5smufnqG+HXXVtlnGeGZPM6f1Y0hoDF5GaXVhJ6WNgXSzP556DsZ6LhsBynNdMmvuymtH9LeXPy1MkG9Stjonjb9ZXUH/eXCl6O/1Cgthb8gBvuLYeTXL1DaAKR9iNKmQtqHQfZZcH9Zcd9mTDoUwyu2QS92CVg+Ypm+dvXT3/wyO5ntBwW9pdUhDW2fX9Pgeb/Amkp8Rn9m8Xe4+ItlY/wNIX+A5Cu9lW9mAqtfPDP63D6ngc6GuQZom3bzrYe+8IHf2/PR3/65rR/82edGvjTjfdNPnfbIY4/9/aK/W/z+bzz208Z7MeiSuejyHjD+tUr2BZ/ov+muX/rnB6av2/GLb//SH7/u4RmLN316yRM/e9Nn9i/52q07jfcSxftXu194pPGLB36iecrnvj2wbu/f3vrNDVNWfelzP7zwt7Z/72vfOGi86xTv/7jpe//rY42D73rHnv/47lUnzt70oYNf+Ie//s+/95HGN//sw2/5wlnGux7yXKWftaEa/0zjvxT4y+zJNf7LqvEf0v/yavx9xn8FPGzazbaf+bn/deGez53x1e9N23XFpkff8eqnPn/D19+14IPL//zNH178oRHjfZ3i/T9b1+zfOv++s78++N/2rPjJRUf/6bc++LG//M47t6z627/8q48v/abxXil4F6w84TUPvvcP5vzJicd+efVvfuj0ZxZ+67jz/uST63/yG//82e+6MZtdBXkuUWaH8nx1Nf6a8V9Tjb/f+K+Fh80wz6Gm2Hg3VpN9iP+6eNl2TTHe6wXvyefVv/Gzu37kMfeVD/7N0985+ddWnzZyzIUjp//hC3+06P633rzwG8Z7g6uk9+I8NuYxfnExvsqHsguKxIe33n3v3VvfuW7L1uteulvzwP1bt7xjK7bRqq9Up9/T6Pd0+s39B8yH3ddc/GXt8wzgLxGvrzL+4Wr8W4y/UY3/rcY/sxr/m4x/pBr/A8Y/qxr/fcY/uxr/3cY/pxr//cY/txr/ncY/rxp/0/jnV+N/yPgXVOPfZPwLq/HfYfxHVePfbPyLqvG/zfgXV+N/p40JjoaHFugN+xh4XiJeHo19drvUGM7w66RL2X5URngmj/OHY7g8bYnQpSHSOEYuEXKWCDkKazghViMh1syEWCNdmsdZCbFmJ8SakxBrbkKseQmxUto+ZR2a36VYCxJipfSJlLZP6V8LE2KlrNspfeKohFgpY/SihFjd2j5aP8v6DtjXyDx/TQ4/Mzl1wspctX6PytcxQl6I/ugAfTMSPx+zms2LcfHFW25/+M7LH7jT0cVD1Ys9Ki4muo0B1Rg3o3/8fDE96xe0eOXZs5BVZO+SLVs337Vx0513brnjB5l8iDkYaY3nOXdIkcY6403StOmirr4Yp0T8upvo/FWcsknyfJUtt6p1DgqrXv7ApjvWbHrwoYfv3YJLY+imLCUjVHymyjQDzfDZNKJbQ7/XCz4nsNGXlkKasoRhDruJeVrq4eMqy8/6BH2TsJqCz3TvD/AjBvKxx4S8OsYrLR/5pUKyyR50E+3RdHGX6dgUOhruUnheoibMia15hl93bdX0LORvTXhmNrX8HVtN3uyM+FEeYpo+ZutlIs2wjit+D3iwjLdG9L9Z/G0IGRwzLA31xWe4PParpDvalv2kHTsinumFzxC/7tryyyxUbpg/9pNl1eTNirE76mO2Pk6kGdby4veAB8t4a0T/ueJvQ8hgP7E01BefoZ/8F9Idbct+UtGO0VsjDL/u2vLLLFRumD/2k+OqyVsdY3fUx2y9XKQZ1vHF7wEPlvHWiP5Lxd+GkMF+YmmoLz5DP/mfxf2gR9+mi7ruVbYuwf/2QTcxXyX4txr/8dX47zL+E6rxv9v4T6zGf4bxn1SN/z3meyfDQ67np8DzMsuNsfXc8OukS9V6fgrJ4/zx9PmpQpeGSOPp81OFnFOFHIXVSIg1khDrqIRYwwmx5ncp1uyEWHMSYs1NiDUvIdayhFgp/b5b7XVcQqyUvro8IdbxCbFS2j5lHhckxOpWXz0hIdaJCbGsbzRU/Mb+QVb8HRR8ZceGiGd64jPEr5MuJeVlIbtg/nhMc1o1eSMZ8aM8xDR9zNanizTDelXxe8CDZbw1oj+pMGhDyOAxjaWhvvgMxzTHFbjDQt+lhFvWH5GfbYR87I/tlBfimZ74DPHrri3/z0L+oexi+Tu9mryZMeWL+pitXyXSDOuM4veAB8t4a0T/GvJHlMH+aGmoLz5DfzwzG6872pb9pKId18b6ieHXXVt+mYXKDfPHfvKqavIujrE76mO2PkOkGVaxe3acnyCW8daI/hLyE5TBfmJpqC8+Qz+xCbVBj75NF3dxHTEMxEad48sh+4dYPzP8umur3LOQHVV9s/ytqCQv+wb7BspDTNPHbL1SpBnWq4vfAx4s460R/UbyM5TBvmFpqC8+Qz+7kuIR2pb9pJod3UWxfmL4ddeOX475iSo3Vd8sfyurybswxu6oj9n61SLNsOz1rAEPlvHWiH4T+QnK4HhkaagvPkM/uYXiEeqbX00XdWXK1iX4J9gOMQz7THheohy/H+unhl93E21cxU/PJHm+crC8nyV0aYg0tDGmoZyzhJweVg+rh9XD6mH1sHpYL2+sFT2sVwTWkeBfvTrUK8denOjVx5crVs+/er56JPpqrz/Rs1cvjz3bv1yxer7a84kj0V49/+qV45GI1atDPZ84Em3fi6u9OtSzVw+rFVZvbNXLYy9G93z15YrV86+eXj2sXn2czDz2sHoxp9cO9fLYy2Mv5vTs1SvHnn+9fLF6cx29PPZiTi9O9LB6ft+rQz3b9+pQD6ubfbXXn+j5RM/2PdtPJlavHerZq1eHelitsLrdJ+xcWDwz7FiSo87nOjMgB/mNbkjwZcXfQaFfLqfpoq7oc8sMv+4m5rmEvCxkf2UXy/vZQpeGSONyPlvIOVvI6WG1j7WyS7F6eXxl2OtI0KuH9cqoj7040cPq+Wov3k+mXr1y7OWx51+9tuPlqlfPJ3r26vlXrxx7WL061POJI9P2vbjaq0M9e/WwWmH1xla9PPZidM9XX65YPf/q6dXD6tXHycxjD6sXc3rtUC+PvTz2Yk7PXr1y7PnXyxerN9fRy2Mv5vTiRA+r5/e9OtSzfa8O9bC62Vd7/YmeT/Rs37P9ZGL12qGevXp1qIfVCqvnEz2sHlYPq4fVw+ph9bBe6Vh2bhmeGXYmySl7PhryG506myz/13RR18ZBkYcS/Lca/znV+N9i/Kuq8b/Dzi57DTzMir+GfS4874/HXpERniv48Rni10mXkvIOndt2Lsnj/JlfWN5fK3RpiDT2kdcKOa8VchTW8QmxhhNizUuIdVRCrGUJsRYkxJqdEGtWQqyUPrEwIdbZCbHmJ8Q6JyFWIyHW8oRYKev2CQmxUsbClPVxTkKslOV4UkKslD6R0vYp63bKPKb0iZGEWN0aJ1LqdST0mXpt2uGzfcr6ODMhVso8rupSvVL2J1Lm0dpaNRbO/zVd1PUwjzUNA7HPg+clxr0XZITnnB5nG37dTcxnlXH2eSTPZ1fL+/lCl4ZI43H2+ULO+UKOwjo+IdZwQqx5XZrH2Qmx5iTEWp4QK6XtT0iI1SvHclgnJcRK6RMLE2KNJMRKGb/mJ8RKafuUvprS9t0av1L6akr/mpUQK2U5pvSvlHUopX81EmIt6NI8dmtfLmUeU/YnurUcu7UvtyohVrf2c1L2MXv9iVdGHUoZJ1LqldK/zkmIdW5CrJS2T9kHsLbW5oHOAb6s+NvmHNjSjPBMT3yG+HU3sSxTzYFh/swulr/zq8lrxpQD6mO2vkCkGdYPFb8HPFjGWyP6TQMv/W0IGaeTDEtDffGZ2WfKD/7dUuAOC325zim7nydwG4KfbYR87I8Vy6s/1h8Nv+7a8v8s5B/KLso/jFeVK9s/tlxDWDwvbOn5NSj4StijEWt/w6+7tso7C9lFxUnL3w9VkzfMdRjlIabpY7ZeLdIM68Li94AHy3hrRP8uigco42iSYWmoLz7DePDwwHjd0bbsJxXtWIv1E8Ovu7b8MguVm6o/qtyMN6W9JwuLyyu/mi54WXFMsIVhI+6F8LxEuUyJ9QPDr7uJeaziBxeSPJ9NLe8XCV0aIo3L7iIh5yIh5+WEZT5ktkFbsl8gX4lyGon1C8Ovu7b8MAvZBfPH7ciaavJmZsSP8hDT9DFbXyzSDGtt8XvAg2W8NaL/CWpHUAb3Ky0N9cVn2I68QP1KVYeq+iPyG90rTc6Q4OP6VdH/ouOu4dddW/U5C/m7sovyd+NVfsr2j/XTlyOW+d+agJxQXFFykH/NJMtRvpz/a7qoa4PxX1yN/1zjX1uN/wrjv6Qa/1rjX1eN/1rjX1+N/0Lj31CNf53xX1qN/0bjv6wa/+uM//Jq/Bcb/xXV+C+3WPU6eGgx1LCvhOcl4ubrYuO04ddJl6px+kqSx/njOH2V0KUh0riOXyXkXCXkKKw5CbEWJcRakBBrWUKs2QmxFibEmpcQa1ZCrOGEWPO7FCulr85NiJXS9hcnxErpqynr4/IuzWPK+nhuQqyUdahbbX98QqyUcSJlW5syTqS0fUp7dat/peybpCzHlLY/EuLECQmx1ibEuiQh1rouxVqfEGtDQqyUtj+7S/W6NCHWjIRYKX3isoRYlyfESlmOKfVK6avdGgvPSoiV0ldTlmNKvbrVXil99YqEWCl9NWX8OikhVsr+18yEWCnnFFL2yVOOFVLOPVr/3uaxrwS+rPg7KPhKzKkPZ4RneuIzxK+TLiXlZSG7YP54L8PV1eTNyIgf5SGm6WO2vkakGda1xe8BD5bx1oj+oakv/W0IGbwHxtJQX3yGexnuL3AHPfo2XdR1ibJ1Cf5T2XaGgbpdC89LlOOpsX5q+HU30cZV/PRakucrB8v7RqFLQ6RxGW0UcjYKOQprJCHWuQmx5iTEWpgQa15CrNkJsVLaa1FCrAUJsZYlxEpp+271r1kJsYYTYs3vUqyUvjo3IVZK26f0r5kJsRoJsVK2aSnrUErbL0+ItapL83hCQqwTE2KdlBDr6oRY3do3SRkL5yTEShknUsavbu0XWjna/lmMGxeSnFVCzqqAHOQ3ujbPon/QxlU4fs8Iu+KYcnFGeM7FjSkrzkUEx5SYv6pjSl7neSW25UclxDoS+sPdHoe6rc1M2Y/q1vakW+cGUvaHu3W8lbIOpYyrR4LtU44DU8Zo7pNhf+YYkqP6DtcG5CC/0al+U/6v6aKuawZFHkrwX2/811Xjv9L4r6/Gv8b6VTfAw6z4a9g3wvMSfbxtGeE5p/uUhl8nXUrKO9SnvJHkcf64T/l6oUtDpK2Be0xDOa8XchTWnIRYixJiLUiItSwh1uyEWAsTYs1LiLUqIVYjIVZK23erry5PiDWcECulf6WMOSMJsY4E28/q0jzO71KslHV7bkKslLa/OCFWSl/t1j5ASqxeu10Oq9duHz7/6rXbh8/2vXb78NXtbm23U9qrW3313IRYKe2VMuaktP3xCbFS1qGU7Xa3xuhu7U+kzGPKvm/Kckxp+yMhTpyQEGtGQqxrE2KtSYi1MSHW+oRYZyXEuiQh1tkJsS5LiHVdQqwjwfZrE2KtS4i1ISFWSntdnxArpa+mrEPd6vfdmscjIRam1KvXdrwy2o6rEmKl7MultNcVCbEuT4iVsq1N6RMp7dWtbcdJCbFSjvlmJsRKuaaTch5gWUKshQmx+NwI3BuWFX8HBV8up+mirukZ4Zme+Azx66RLSXlZyC6YP7OL5f0moUtDpPH5CzcJOTcJOT2sHtbhwrL9wliHLyQ5ZeMI8hvdkODjOIL6lajXx8XGEcOvu7biVhayv7KL5f1moUtDpPH85M1Czs1CjsJqJMQaSYh1VEKs4YRY87sUa3ZCrDkJseYmxJqXEGtVQqwFCbFS1sflCbFS+ldKey1LiJXSv1LWoZRxNaVPpIyr3Vq3U9bHlHVoUUKslPXxSPCvWQmxUvYB+B0/7C/zO35lxwbIb3RDgi8r/g4K/Ur0ofdnhGd64jPEr7uJea7SZ1f2V3axvN8idGmItDVwj2ko5xYhR2HNSYi1KCHWgoRYyxJizU6ItTAh1ryEWKsSYjUSYqW0fbf66vKEWMMJsVL6V8qYM5IQ60iw/awuzeP8LsVKWbfnJsRKafuLE2Kl9NVu7QOkxOrWdjul7VP2AVLG6JT9iW711V67ffjiaq9PXg6r1yc/fP7V6xcePv/q1n5hSnt1q6+emxArpb1SxpyUtj8+IVbKOpSy7ejWGN2tbVrKPKbs+6Ysx5S2PxLixAkJsWYkxFqfEOvahFhnJcRakxArpb2uSIh1dkKsyxJiXZcQK6VPXJIQK6XtU9btlPUxZR3amBArZX08EvxrbUKsdQmxNiTESmmv6xNipYyFKWN0t/p9t+bxSGhrU+rV65u8MtqOqxJipexPpLRXyj755QmxUra1KX0ipb26te04KSFWyjmFmQmxUq5bpZxnWpYQK+X+Qn5HF/e2ZsXfQcGXy2m6qGtaRnimJz5D/DrpUlJeFrKL2idteX+D0KUh0vgdyjcIOW8QcnpYPawyWLZHH+vdBSSnbN1H/lsCcla3KWe1kDMk+DjGoB1K1PlPxcYYw6+7tmJaFipnZRfL3xuryfvNjPhRHmK+geTdWk1ev5XVJoFtutxe/B7w6GK8NaL/0rSX/pqM2wRPQ6RxHbO0FxUWz/oOE9YmgYV2tDKZ8oN/f1DYQvl//q/poq4Vyr9K8K8cIt0MA3W7DZ6X8KUbYuvmbcV93bXlu1moTDF/3P5vEro0RBrP1YbKG+UorOVdijWcEGtWQqxVCbFS2mt2Qqw5CbHmJsSa16V5HOlSvY5KiJWyPqYsx4UJsVLWofkJsVKWY0pfXZQQK6V/NRJiLU6IldLvuzXmpMzjCQmxTkyIdVJCrJT2Stk3Self3dovTOn33dqXW5AQa1lCrCOhL9etfp+yb9Jr08phdWtfrltjYcq+XMpYmLIcU9qrW/tfb0iI1a39r5kJsVLW7ZR1KKW9UrZDKetQt9o+ZfxKOS/XrXNDKf0rZd+3W/uY3dp2vDEhlrUdQ4Rt6fnV5nrT0RnhmZ74DPHrbmI+U603Yf6qrjfxuxTt2D9lPExZj7p1rjxlDEuJ1VtvKoeVcm4uZR1KWY4p1wNS9nW6dR4mpX+l1Ktb13W6dY4iZTmm3KuQMt7zub23QRqf23ubkHNbQA7yG92Q4MuKv4NCvxL9pccywjM98Rni193EPFfpnyn73wbPuH92u9ClIdLWwD2moZzbhRyFNSch1qKEWAsSYi1LiDU7IdbChFjzEmKtSojVSIiV0vbd6qvLE2INJ8RK6V8p9UpZjin1ShlXU/pEynKclRArpe3ndylWyjgxNyFWSttfnBArpa92a38iJVavD+AOW9vR6wMcPr16fYDDV469PsDhixPd2gdIaa9u9dVzE2KltFe3xonjE2KlrEPd2nZ0a9+3W/0rZT86ZTmmtP2RECdOSIg1IyHWtQmx1iTE2pgQa31CrLMSYl2SEOvsLtUrZTmm1OuyhFgpfSJlOa5NiLUuIdaGhFgp7XV9QqzrEmJ1q6/26uPhy2O3+levHer5PWNdlRArZR8zZTlekRDr8oRYKdvtlD6R0l7dWh9PSoiVciw6MyFWynWrlPMTyxJipdzPZHMdtv8Q6xSfSXi2kHN2QA7yG92g4Gu6qOu1tn9vDTzMCBfXxfvjsWsZ4bmCH58hfp10KSnv0N7Fi0ke589sanlfK3RpiDSOjWuFnLVCjsI6ugNYgx49my7quk6Vdwn+e9iehoG6YVtVomwXxPqS4dfdRDtV8aV1JM9XLpb3DUKXhkjjMtog5GwQchTWnIRYF3epXiMJsY5LiJUyj/MSYs1KiDU/IdbchFgp7bU8IdbihFirEmINJ8RKafvZCbEWdmkeT0iIdWJCrJOKe2u/sA9p7Wp7/cDsK9g+o574DPHrpEs5eeF+oOpbt9c3yf40I36Uh5imj+orcLtrY+cBD5bx1oj+lGLhUJX16SQj1m/ys5ePL3CHhb48plF2v1jgqjGN0Sk5q9uUs1rIGRJ87PcV+6ynxvo991krjreCfVZll7J9Vp7j65b+3LkJsVL257q1LVqUEGtBQqxlCbGOhD5Ft46vUup1VEKslP3flGOilD4xMyFWSp9oJMRKaa+U8atbx6MpyzGlXt3adqQsx5S2T1m3j6SxbbfZq1vb7ZR1uxNtrY1XcHyTFX8HBV8nxmqGXyddSsrLQnbB/PFY7QqhS0Ok8f6CK4ScK4QchTU7Idb8hFhHJcQaSYi1KCHWcEKsRpfqtTAh1ryEWCckxDoxIdZJCbFS2mtOQqyU9XF5QqyUfp8yFqYsx5kJsVLGnJQ+MSshVkrbL+hSvVYlxErpEyn7Jinb7ZTl2K3xK6V/payP3RqjU2Kl9K+5CbHM9rZ+h+Oxc0hO2TEh8m8IyDm/TTnnCzlqfJn/a7qo68+M/4pq/D9h/NdW4z/J+DdW4/+k8V9Xjf/j6hzMEvzbjP/2avxvMP7N1fhPNP47qvG/2vi3VOP/K+N/UzX+9cZ/ZzX+/2j8d1Xj32/8d1fj/7bxv7ka/0Hjv6ca/zeM/95q/Jnx3w/8JeaLmsb/YDX+ftP3AXwodDJ8m2+6D+gzz1/D4jSTVSeskrpnId1RP47jD4A8zKMP64GSWIMirUqZ3O/8+UL8oYAuSk+ec2gnzwsTYl2WEKuREGtDQqw3JMS6IiHWtQmxNibEmpEQ65KEWNclxNrUpViXJsS6PSHW5oRYdyTE2pIQ600JsRYnxLozIdaqhFh3JcS6PiFWyrbj7oRYb06IdU9CrNO7FMv69zavgO3SjSRnhpAzIyAH+Y1uSPBlxV/rX2J7VqJ/eVJGeKYnPkP8upuY5yr99EtIns8uav+x8TZEGp990M6eguMTYqXca9qt+wpT7sPs1r2mKfe/NBJipdwnl7IcU9orpa+m3K+d0lePhP3HR8LetpT2SvnuSkqf6NZ3RVO+D5syRqfsA3Tr+znduj+0F78Ofztk4yXso/N7oWcJOWcF5CD/WQE5q9uUs1rIGRJ8WfG3zXHZjIzwTE98hvh1NzHPqcZlyi5t7qUeivEr1MdsfalIMyxbMxjwYBlvjej/Q+HsDSGDz+CxNNQXn5l98veh//3weN3Rtuwn7dgR8UwvfIb4ddeWXwb3pGP+2E8urSZveozdUR+z9WUizbBsrWTAg2W8/N78p8lPUAb7iaWhvvgM/eQ/FbhqnwrHx7JxGPmNTslZ3aac1ZFyrmxTzpVCzqDga9rNtx76wgd+b89Hf/vntn7wZ58b+dKM900/ddojjz3294v+bvH7v/HYz7TpnzcY/2XV+GerPT8l+GepPT8l+EfUnp8S/BerPT8l+C9s79u3meM9P86Vz/vm8ryZ2utTIt+r1V6fEvxL1F6fEvz/pvb6lLD7N9RenxLy/5X3+jjkveAT/Tfd9Uv//MD0dTt+8e1f+uPXPTxj8aZPL3niZ2/6zP4lX7v1cbXPp4TsKWqfTwn+aWqfTwn+epv7fBbxnhIXz9un9gj1xfMPGv9bqvGfbfxvrcZ/jvE/BA+bxd/j/uhXpv7jz++t/fIXv/HA27998sHfXbfn13/hvAOfO+2C0Wu/+tzfXWG8W0F2mT658T9cjX/Y+N9Wjf/Q/q63V+M/VHbvqMSf/anxv7MSvxsy/nfBw6bd/NXuFx5p/OKBn2ie8rlvD6zb+7e3fnPDlFVf+twPL/yt7d/72jeeMd53K96w3ofaiB9WvP/jpu/9r481Dr7rHXv+47tXnTh704cOfuEf/vo//95HGt/8sw+/5QuH/PU9h9DK9V+N/0eq8c/J+4ffoP7hIGAtgfv8X734PcWNjQOwbTde6ydPB2FZ8dd0Hqqmc19GeM7pMYnh10mXkvIOjUmGSB7nj9cUHxG6NESa9e1tPGA2/vayl/7mtv4XGusNgly2ax2el8jnwli7Gn7dTfSXKnatkzzOH9t1SOjSEGn87qQqvyEhR2GdlBBrXkKsVQmxhhNizUmItTAh1uwuzePchFjd6l8LEmI1EmItT4iV0r9S2mtZQqyU/pWyDo0kxErpEynjKp9DgnxZ8df6Adh360T/yvDrQs8q/YAlJM9nl7zPZe9qPrz17nvv3vrOyx/YdMeaTQ8+9PC9W/oQ2o3vDbFVEBWfZW587jGtn55NI7q19Hu94HMCux/kNiFNWcIwrceOeWp6+NAWTjzrE/RLCGuJ4DPd+wP8zo15bJ3k59fh8tiKPeWgx2L+uOfaFLo0RBra0BcxVA+5rF7T3VhLWtSki7fc/vCdlz9wp6OrRr8v9qi4gOjWe1TLBG5G//j5AnrW78JVNTRYinGZ/OJgjFgbSU4vGPeC8csjGPcLPvaYYfGct5+X7crcKOQpOTe3KedmIWdQ8DXtZtvP/Nz/unDP58746vem7bpi06PvePVTn7/h6+9a8MHlf/7mDy/+0Kx8CuaNjfH6ov0HSV/DneLC5VUj+guXjfHdXsjLa5h1+4oadtHD995zzZatb717y9u2/CBW42T1IRM5EMfV4gr6/TrBp66YNnyyZ/XabcOVa/nayvhAxw6BVkFUfJa56oHudfS7SqBr1WvgQBcKTlgqg0KuPetz/kCkghjPNYYCmXO9prm6xx7JTXOMx8Y2zT6P9TXNzDfF+T28RrSPFE1Gm549biaFdey1AS9dvTbg5dIG9As+9piQV8d4peUjvxrOn/9BN9EeTbv5P1vX7N86/76zvz743/as+MlFR//ptz74sb/8zju3rPrbv/yrjy/9Vpu16/o2o8J1eSQ6SJ3gJmDx4O7k4rdvrdh4Des0SJtOWKeBIv3iGdse+Y2uRno9tGhMv/dDZ9vmfosafv2me+++Y9PWLWvvf8vDWx7ecsfrHti65aEL779j7du23L+1dNf7Evq9TvCpy4zERsZ7tZCqwlhD8Nc9WL7CMyxetP7JwpBTf/Dv2BXjMVWlxAq0PpDX0GiR7VB2tJhFyjm1TTmnCjmhDmrVwKN0VnNhVp55GX+kMcaT/xuGtH7Bu6H4WyP6TVCpfomCBQZg3xQnNkjYQPI8osmzTdZM0+fR7+Pgn8vJP/soz5hPpfMwyGC5+f1Kjw6/St20BuW96eIu1U0zrGGhz6tIf7Svsjn7FfLz1LavM4N/TQ4/YzlKZ5MznFAOYlldMLthmXBHrkFy+JlvzhjphgCPdcj977MNLRPro4pbNaI/Cerj7wfqYx/lH8uAD9T0dcaqxMSYmBDbBhn9H5ZsgzCucRvUF6FfzU2sU/n96W4szz4sJ56pDjF3TIeJdihA64tb+f3txX0n61d+v7m4V/Xr1aRf2fqF/LH166sl65dthOf6NQfq119Q/cJDzNmuvCkAaTcT7QjkOxZ3CvHm90cT7UzCRZ+8jvJruFfPHMP/epHfIZJl+OpvfsX4DurNvoMHNZ8J95hmcvgZy0F+o1N1AX3n2w0tE30Hy5d9x+jPA1t+t+HP4wjplcLO9nw2PGe5s4h2DtHiZqeZpONs4lV/W+nYEHLmEO7cgP4zCWdE8A05nVf1N1bfWULfIaf1V39j5SDW9STH57vTZo7hoh18vnt/cV8j+hHw3RnF/bDgZ9/FvK6kNGwTMI49TDrjBjSz0w2C1+jnEz1i5BePLWyfgW9sYbw1op9X6IljC8vbXCEvz9sCT96wPHBz6HySbfRnQ3ksovJAe1l5DLuJtuE6sAB0YdrNHhssAz2aM/2yuF6oPOYYy2f66TYLOsboEzYwDBUX+DCBuUJnR5h9gpZlzBF8SgbHY7QZ7n8x31jYIn2ByJsTz/oE/TxPfp2QPb8F7lyBo+L7fEqbJdI4dmF+Me5ZPeOYyHFvWqC++OqE8qt5Ad15M+88ofvcgO7Kfhg/Qv0G+x3T1mfit+l3FzzjGGv+jS+9I43x1oj+IhEzGRNjIer1Jg/mWsA8kTCVz5wJz3grXaicUJ9h56/nSneMJfws1JdxQgeMhcpnff04tofSYbbAUXGTN3Krfnhs3cT+9LeP0DHG62dqmWXHGN8/aozvlohY0c1jDJ4z74YxxhDh9MYYPxgzJBpj/CH47lsqjjFWUFqrMYalmX37BF+D9DV574e+7zsILwNZ6Df5PR/uMhvwncgTrysY/Q9Du3dKkfFhwf9awmWf4GfsE8zvAvlUbRjb7fkiYdBNrIsl1kMuDPm/Yc+tiB1Tf1SdV+OHukirRehy/z9uevWmgXd9luuV6cLPYvoyrxX0ZiseNzdd1HU+bt5wJBvnzJ2baLP8mgJppkPu0yeTfvMq6hdjP8RviLQH4L5MWSisRkKsoYpYI268j2I9VH00nrtR88x5OX6S4jbWldeQrpnQNRSHmN+J3yoOqXWb/PoPFIdwnr2Ef50Z6p8Y9pyK2LFxyNcnQL3qIi0mDt31vQsf/PQ1nz86cxPjbb94xnFI+eRrBH2b9fwMFYc41mAcmkNpGIdMBxWHKrYpZ8TYD/HVXBLHodiyUFiNhFhDFbEsDoXWFjAOcf9uROQH4xCvZ/0G9Nl+heYasT5xvFP9N9XH5LSZAjOX/V89/c+B4u+VkMbrgWqM7iAP9gx9HXl4Hd3o/zPY5rdJP67TRwv9VHnhHpvPzvTTjQTosFy4/NU6eKjvH1suw26if/HeBxwz94tnob0PRsdt0pegDD4faEv5g6OZ0CXUljJ/fvHeHlUP6kKHVuPDPxoZT9epOR2zb76p0+J3salz3Zat19616a1b7rh2y+a3btnKuzb5jVGuVbNJI3WZlvyG61T6zTv/GvR7psBpJVPt1OFP35bdqXOO0PlwyjmvTTnnCTlDTpeJ+mty+FloN+Z5lB+MSHwUa9ldMMjfCMhZ3aac1ZFyXs75GXK6LuZXm6ODpTF+hPh1NzHPVV5ymUnyfHZpc4TSzIgf5SEm9+rmijTDsug94MI9ZF4V7y+aAzVSPp1kxI6U8xbs3zw9kvzClm7KyHgZMyFNtcpXUT4O2WHhGN9ggRnaVa3i5YVuvC5l4+WFPTkdlXNRm3IuEnI63Z5dRHI6EC9HXi7xclY1eTMz4kd5avacZ5dUvFSr8YiFKwxIfyLFS5TB8XK20BefYbxcRjEL9eVZB2X3mQK3IfjZRr64fFqiuPyxBWN8Z0TE5VAeQ7vQh0QeQ34zKHRXtufdC7MCOpdd9R6KlBOTn5Ccw5mfUF3AMrgmoBcfGTinBdbVhKVWrpUPss6DLeSEVpwHA3JmtylndqScycoP75hMOWOK/JOxio8yW8XIjRQjQ29I5Be/EWj0PwUx8oZAjOT8h/oSFccm0X0JXqltty+h/CLUl6i4onCoL9FqZZNtPU+kGZatwA648Cppjei3UF8CZXBfQq1M4zPsS9xGs4eTVU8aCeUgFp8i56uP91F9VLtqQvXR6HdBfXwwoj4q2wwG8sOfQ1LzMaHDC1VdmR2gV76u2nH2dcNwru0dD9FxxfDrbmKdqBJX1I5vVW/yGXCzazEDfuGWh1asXHXxD6a/3/ngVrap4fKu0/mEyz5nv5kv1413MzWEjPxi/5lDdFzuPD9eRqdWtK3SVb3h45HL9kuQf9CDZXU+vzYCDb8dYvTbi3qu3ohV9VO9HaPy2iC+hkf3fpGHaR4+/PwIpmGe1wfybPRPBvI8q0WeecyE+s0iPuxHcj+B8zDoJvoAYsT0P3GF62w3Pl9lVyDPFnI6vSp3NsnxtXfPUXundkCjPvbZGV7Ffju0d+8LtHeTlf9WdRrzwj6F+ap5MHl3qNH/VKFEm7ss5akTvFMsE/rn+fsZKlOV91CZGv3dUKYfjCjTUP0I9UVUnJgZoFfzAGrOtnM7VbOvxPgo4qtdYFX6IqoPr8a+ZfsihvunkCHUv1VfhPlUX2TEI8NX97h/MJuet+qLKJ18tO30RXgsV7Yvovr8bR5D1uQ2sd/pcaVvzrTP6X4D06v+R2iNEXcEKttshHSk/1XoZ5xOu+5Rh/M9+jkXVxbIb3RDgi/z/DU5/Cy0K4l39HRiHSm/Qqfv3Af3mGZy+BnLQf7QPoI5bcoJzQu28vW3Ffet+kSfK7FugXJ53WIhtJ9/QO0n8ofmRXmNEeMw78pTp9apXX/YH/ijgF6Mx77Hz7islD41ysfXRsZ0+XJAl2va1IX580v5gd0Puon2LhF/ow9ZNfy6m5jnKv2DPpLns4vlXZ2q1hBpqLtPzjVCTkb8rfRK+LEMgzyF6NZ7VMsEbua0y9nvU+iZyhpiv3iIwrwxOajn39LQgZvWpou71NCBQwwWD1dTVbT4LFTN+zxY2NyHDoTDPL+OsMo25cjvGw7GHipo9PWib9pm9+yqDm7luCo29PAyvtouUBdpMS+vfK1+3u/+zUdf+G8Z8Zsu/Iz9Rg0hXyfo29wWcoV6eQWnKPILfWQmpeHLK6aDenllpKJ+MfZDfLVcvxnuy5RFQ6Str4hlL5yoocThikm+6V2LTxyfG0UBq6lOFZtCJ3qjToPENyh0d25izMmvptPX9+kyPLP/VCEL/R1p50G+V6wYr+uQ0NViRH9AhhPPMue3DcvoE7x2SrQatvp0Q341FOnz6JljqOEN+23Z4U1d6KPkXNmmnCuFnE4uwaLMVsOvE2eN8WA88Q2/thb3PPyaCsOvUwpMNbTgYSSfWo8xIb84Bhq/7yAzjidGfwbUKz6UZ1jkeStg+vysJuTm9ys9OpxF/ZmKfQ7Z5+SpH7QDx9b8utTpPGGcxmEc22CmoN8YoFfTzuiTHLMxj76DnHzLZyx7TgvZvDSmtp8xFsq+KiB7XgvZvI0utA3FyvT6uWM6XET1twY8qtwvI0yjv3TOGObakpiXezCvnzWGuT4QE9a68fI47vEzjnvMn1+96YbxOrHNMM3XJ0A5a4WcjLBa6dWB6QY+/y/ldAOf/1dmusHcHJuINxI+6tIvnnGRIb/RKTnHtCnnGCEnhPVGgWX0UwT9MYI+oWtY+mKi2xhQjXFbucZieuZzDbv6SWZ+zzNOXDSs47DAyAJ56hfPuKgzIUvJua1NObcJObyY/8PUO0L5JaLl4xb9BuAhR/6Ks32Po73sUpHft5iFetVFWsxsz8m//p6feu2yu67MiN904WdcJacL+tsEfZuzbo+q2R6TrWZ7BikNy9+eqdme6RX1i7Ef4qvFxM1wX6YsGiJtfUUsm+0ZAP5QXZ6smNEJOSEsNQNk9GabAUGvYpLR74RR45k0G6Ps7cSzPjcxHl1b/B0WWBd4dFeyDT+/GoLf6DoYE6dgOaGe+Azx625inqv0hlX9UHaxvE8XujREGh9dqOLldCHn5YRlvjnkJvpv5vlrcvgZ2znFxg0usxRYKTZ6WH2dATRr4B7TDIufcbkg/wxKmyLkqHZogNLQbuspDdvzlZSvAcoL3peNQ5nQjzdW5BfORn5olpaJM3Nq5YLj9ldnj/H94ix/HnnkOwPwnKDnmT2j/xj1XXE2sERskzN7fKyTz3YfL2G7/LqG8mL0vwO2+48B23Hbj3WCV8DRHtMpDWeEEQPTnIubaUf+mJn2Nmdio9u+yXiRX8WYNldEayZPzd6qcpjptE3VbK7VMRXrOJ6pFzRUuzZMaVi/V8C9L55hnnhGWuk3WXFTyTmrTTlnCTmhfmKMrys5SudWseyLFMvUpnpsB95Z3PMOko9BLPsyxTLk5/Ljvim2NfnlG6v5VqXqHv2+EliVUnl+Z0BnlOHcxHrDbZfR/zm1XRXH07LtwvE+25BjcEW50bPxhp/qC+uq/53+C+toFUTFZ5kbn3tM66dn/PHmdfR7veBzAhtnPNWxPqH9GJinIQ8f2sKJZ32CfjphqRGf6d4f4EcM5GOPUXz57x8WPKEaEOPB+dWJEY1hzRBYbfZmZ8fWTMOvky5Va+YwyeP8cd4bQhe1p2Ia3GMaygn1ThGrlhDr6B5WD6uH1cM6DFiWhm0jz2JhO8V7bXx7wjEN9QstXPO+Q+cmvnph6fk1SPqWbG+GY9s3w6+7iXmu0r6pGUZllzbb7xmh9hQxTR/VnvKMjs0K+D6qh3vrkH5lMZJL6dcvHps3e7zuqh8UU86Iq2ajQhs2Oun3qB+OsM+drWX69n3yCNvofxZG2OfPHq+zGmE7jw3QhwyD86TeIylTX/NR9jn0EVvUi1cZld/jqNv2iDbcRD8O+QLPtvjKaD2VEe+l5zLivblG/zSU0WXFvdqHF7MPTMljHxrw0PeRfkZ/VaETrrLGvCKpfBZ97gqPvI0g70TwB8unI9lt+t1s5XdYn9nv1Eyeqv+h9gD9NOSLLDsTWOgHPPNl/ANOl4Hh1Yj+VlHmsX7O5Wr0t0eWa6J4IssVbRWza0G9VxPyA7XDQs20sh/3Cywsay7XVnXZ8Lhu3RcoV+PHckU9uVyN/sHIcsV+j+Ggvk0XdclyRVtxGaj2GuljNkWyrvmlVkamUpp67TsUv9EPYspc2ZfL/IdFmXPfX8WF2P3M+fya7ckvZlCv3frAW7cUU6iOrtCUZ+bGTwuiGrMEvyPejJ7xqwkqfIY2eZnsAaenHDl8Gv0OYfJQ+M2vmC3xWNydmIS3Z6m2xLcKazzVF6pmoS75YXDV/FrnUSMT/I6wMvEsv9Q2dd+bd2gWk8fF5uuN+FoOfJsE6Q8GWo5QD8cJHUIzwKiPyv8wpSFf3SMHWzR0I27RjP79kS2aye5Ei4Y24hZNjaCRnu0d+rAA2qRB9Gh71aINk5xW1dDCqzq0DXuVPLJS/hLqmYXso/wLy61Bab6ZFMN2RNeJUTDmh30h9qMRRq9OE1AHfjWIXvmJ2s8TE5fyK+QLOHLkmRC1rzQ0ApoOWKoJ51G50X9SxADDHGqRt5gRIMZx3o+FXaAZlIZ8OFNh2I7o2vTHGcofMT8xszJqdS+2roZmuXnvP46weNYT5eLejS9O8h463yFzvlkSfmPa6D8Hs0ZfoTqi6nioDNT+Maz3vL9WfQAjhBXqC6gDLGcFZKNe/Llj/mii2uPWwXZ8iqorGJ+5roRicX7F2EqVU4Po0TZl9/PNpLTY/XwNyDP7p5o5UTFc1V3cN/txqruqDxmKwaF938iP+45Rh7+CNoJPQWm1N3qrB/NvAu2OykMm8hATi1XdwtgX6mdzXFQH6qnYx3ER6yfHRfw8rRP0vF/O6L9T2K/N05DkfjmOdXj4qup78R7uQycmwdv8/zRbY04pifm9yR2z1Dod61q1SWaThptYNr79ooil9hJzPRtwerxkeDxGnlqUq5ppQ3twTMV4yzF1upCr4i1+QvrkQg/VX8MVrOE54/OtxsvIy75n9KeBP48U9ynjBp+OhXGAx3VlT/RCft8pcJbuXNt79qPfSTB8depclak4Vf/UnEGbcfPQOwmqr6LKAd9J8J0qgx8PzK/JjmuhuZhWduX3uzCPXJ8Rm+NATJ9MyfP1yU6mup+qT/Yh6pNh/eL6j3Wc6z/6O/cb0Ibcb1AfbcAYhG020p8JMWwd2Ub5cmiOJfRBIdRn2E309TkRWKG5PvVxojkB2agX8rJsX51UddFs04nxFPYLuC6GxpL5FWMrVU4NokfblK27PA7D9p3rNfr2COR5nafdxnxgu811d4bQFfsD5htYpq9342WqpR18xu0s8hudknNMm3KOEXJCWK8XWEav5jA7fDyOqbiM6DYGVGPcjP7x82X0TA0l8VLFlHn0di6umDKSr7AwhOOLGVeTXhhebiKsspv1kN93ulLNozsPSY3uwaJatXl0zsGYYyIqvqZ1EMvDLtUt5VfG1PCkLtJijs75lZ+7esbnP73q0NEvsUcoGL2alr9J0Le5sXhfaLpdHZ3Dx+pg+R8aOrqJR+dUPNpnX4z9EF81RZvhvkxZqC7p1RWxYo7O6XRM4mmWh2GIf+yKw6OLdSHe1QW6WDfokS7QxZrgR4UuofYgg2fctqDuoU3inK+y7U4WKefmNuXcLOSEXsLgvyaHn7EcpXOr18r3U7d2CqSpKfR7i3vevLoGDmB9hrq0ajN+Jn6H+h2sH75WjjR1j37vA//k18pVnu8N6IxTkY4w8nvukxj9v6M+ScXXreU0Ob9UG+qvVJQbvaPN8FMda1UneZy/aq+V80AWrYKo+Cxz43OPaf30jDeuraXfVV4rV634gMC0mhd6FbzqYW2I2y/kcE+7P8CPGGpx1DAUX/77bsGT8sAO7nGnwFKvqLfZO47+MjW/dlextxt87Q7zx3lXG7vUogD3XkKv26EchTWSEGt2Qqy5CbEGE2Id3cPqYR3BWGpjW2jU/ubiXo1eeLak7MgL+fsDcm5sU86NQs6Q4Kva9jUCOlt+1GeHMkrD/IQOEVYbD1u9Wvrnc7RM3yt3PBIy+jNhJPRXc8brrEZCzulRJ5aDc3pU3OZiz3S12IN25T6ymu3DcrunuA+96qR8IbaMvkll1Oq1SNOH3xU6GsroOzRaRX7fe1GuhTyuh7Gv/xr9v4hNLUq/AY88NXrPrw0eed8HeZPw+u+I8juMMzGvE6p4FooX6l0mtVjIrxOGXiHNhJzQxnj1OiHr7tzE1Yzphb+qTU7TBX9IP2W3xK8T+j7cO1PwO+LN6NlMD5bh5L9x+BrzOqF6Y5hDxCxh8lCR5VfvdcKX3euEaz1qZILfEVYmnuVXq9cJucaGTKxMVfVF9GOFS4cirOphGb3qCai5eZV/3lqIfAMeOeoF+fziFs3oT4K8TsLBB7JFQxtxyImdOTH6VtvKuaqFXucJHfed6nVC7qkpfwm9Ttjq9S32L2zBQ69vhXrViV7fmn64X98y26jXt/gzD5h/fpVD9aJifQFHT3/uWWNCXPQFXvNRr3WgDX2vdawTMcAwp7fIW0y8U5+PUK91cLxD3UPba42uTX+cpvwR8x8zygvtAWlVVzn+qIOfVBeB28lWfhPaLotrfPtpxIe6su8NBfLmRN6Qn8sd5RzTppxjhJwQ1tUCKxR/OrzlzlRcRHQbA6oxbkb/+PkieqaqOV6qmGoevZ2LKybkD7lD1qacLFLODW3KuUHI4a0g7ynCbptbqnaoNwEsn4Y9ryI22ssuNZoy/CEhz/Sqi7SYrXd/17juM/d+6wM/nxG/6cLPuNrOF/Q3CHqz1QLgL2GrUdU0mWy19W4epWHzYjqorXfzK+oXYz/Eb4i0zXBfpiwaIu2aili29Q67cpMdM3jr3XboQvEWs8nSxbZ0PN4FutjWu92HUZeYjQS8mN50Udd0lId6OtKFY1+7GwlUFyS0kaAhdFHDnd4Z1j2slxtWqN8TUz+VHNWm8DApv3Cx7cNzx3iQz7c1lBfbjP5b88f4/n2BqaYFeQqDY0r+FzeAcTtr/Lg1FGl4a6jR/weI5bw1tC7yjIt8Qx4dakJufr/So8OvUJ+5QXlvurhLbQ01LLUpkPuUamOe+oKPWmivB+Tc0qacW4ScIcHXbj1ROndSTn5ZnVN2uxXuq9gN+UPlU2tTjvL3fiEHp3BixncV60EtplwQv+4mxqAq/ZjQ1Gx+cT9mptClIdJ4RbXsiQuINS0hFm+IVH5zq8Aqa6+EU0+m4vVEd41HtX6Bm9E/fn49PfNNPRn24QzNnaj6Ss4Fbcq5IFLO6jblrI6UM6NNOTMi5bzS7PZyzk+r/Wnfnatl+vanWXNYI/rZ0GX+F+oyY33j2Fb2zTTkD70Bd0ubcm6JlDO9TTnThZwQ1sUCy+jVapNaBUvYNFn6KUTn+8JEJnBbNU2n0DNf02S/D6c7rGtTzrpIOa9U914nsHruPQ5bFZNvv5VzccWkdnkfTre7pE05lwg5/UIOTti2aimPLVZArOWziZHj543RHAf3tp9umtN7LLjMyn76G/lDnxi/pU05twg5jOXrLdxR3PM+l1cVtlH7XAZAD1UXeNSjekm3iPwYfeiTz8qWuE9reoRs9Xar0Q+V1LXVPhXuTaojwWN1vWqSdQ0dw92BN06jtyMfrjdOy70LztMraBVExWdckzCtn57xruNL6HeVd8FbLZnxu+DqALKQZznxrE/QzyAs38dB+j3yVIkiH3uM4st/v0vwhGpAjAfnF0/ZpViW4WVMpLOaWfHw0bmxNdPw66RL1ZoZ+1EMy/ssoUtDpPF0pTqkWB04qLBGEmLNTog1NyHWYEKso3tYPaweVg8rEsvSsM3mZS1cYuN35zv9DriSc0mbci4RctS71Jnnr8nhZyxH6Wz5wbY7ZokttCUF+RuUH5w0wtH8rnlapu+NDd4qYvQ1mPfeM8+fR7Sz5Yt1bvOtiaGyH1tQ9Qf7cO8p7lX9qVGaOni8VRk8T2Wgzi+YIvTh8wu+DrMu76cyUAcuh+qNksc+4nsxd5D0M/ofh9kOfjce+Yc88nwfJfsRj7yfFrMrHXxbZ26nP0bXyk/5DTH005g3ckLfdjV+37ddeT3M6D8iyjzWz7lcjf6XIss1UTyZW/asDTWzFnojV/mBekNNbeOI+XhL6CV7Va7qPDcu118LlKs6lRH15HI1+t+ILFezZSfKFW0VU65IH9N+hz5Qw+N4xFIxOjTDqsoVy4BjtNH/bqBc1Sx3KA4b/ee6IA6jrWLKNfQRvlblynEYy5XPKMG2juvyZMXoPxZlrvr8UyL0853umfCMkhkeNeYIfke8GT2b48EynPwZTquyyS27A05PgbLJjf4rwuSqmqpdl1MoT/llU49Y3J1YFDD8upvoElWmHkNdzxcVK/7yTl5VzdTiFZdTKzmJzyi5xKNGJvgdYWXiGaYpV0We0Dv+2EIfSyMF9Xm1UORTPX+jtx6or3dxaPRI9P8v0AqFesH5xdFafRIIe8b8/j/mYQ6lId+QRw62jhj5uXU0+n+KbB1NdidaR7QRR3n1EiTSx7zcii9s8qwSvjzKVRptzKG6Vehg/1d+qkbfqjfeF8hvq1EZ+xf6xCxKU6M55QtG14mZktAno0J1Kb/YNiHfQds0XGs/UZ+FiolL+RXyBZxd2BWYNYnZhqWaFDU7xz6h9h1lbqLvhfxR7eru82DF7lMx+sVFJeUYxbpknr+mOz+LmfnttJxpwKds5kiPTOhh3a+K9TD6pRfDT3VEnNpPpuym6g3PfGLaA3Bfpa6oGYgUWJam6h3vbi9b7y6IlLO6TTmrhZxO15ELSE4toRysM6tJzpSEctTsu5odaFcO+utKktMvdMj1umj+GE/+byqk9Qvea4q/NaJ/FlZh1hb36tRprlNTAc8J+pUeeZcWMtocfsqXXzn+o83RdpeT7fohTcU0tp3RvwNsdyXZDvXiuo124r28UyEtNM6Ime0LrWSq2dHQSmab35OJ/iwzf0+mon8EvyeD9cLsYvmbVk3eoc8yx87k42eZ0aYo37C43VT9DRUbeWyE7Vro5OOiuyZ9mafSuDz5Gfsd8ysszMNKoVeN6N9BMQXtU6IMT1Yxl/2/Yn/t5Fj/xzMClbz8qou0mEOoPrVy5JzPnPf7X86I33ThZzHjF3V2pdmq4regTgzN9KtDqGqUpvqC6hCqilORJ8bYD/FV3eQdObFlMeLchPgdal84DdsXbnvUzL9625L7AhazfGNEXjky+keg/TxAbbKKo1PhGfum2nOvTksfdhPj7FAEVn9Admh3tpKNevEOY969rNoDVT/MNm3O78hPguMcdcxKGNLH2EqVk1pNGqI0jvOYhvmfRmlqXk+1g/hG7wFPnxHzkcGz0Fw69je5LzrYApftqfo3qp+o6j+/V6J25IVOEVB1ieOGWr3meuZ7bZLHEEb/E9TeVzzIQ44heP0C+2DKv3lsYPQfh9j2057YNqUk5gc8c2rO6f58m7Gg1umzhFvFTa63WDZTCWuqwEKb8jKs2WZA0CPehJ1EUAa88o35m066YxnUKS22X271Iaf/w0IPNWbDse4nyffUKQXIy75n9F8Af/5VGuumiBv87iDGAX5jq+y3stWXMZU/Wxxo8zDb6LGu4avvuVcZ66r6p069aDNuHhrrhna1oDwc66JNUT6u6zo3+XEN7RQT19QWD7UGyfUZYwTHAdUOqrlIlocxAvvif+iZI8R89AtcHgcjL849hk4yUnWc63/oTP3QLqdh0EX1ebDNRvr/DTHsH8g2ypdD/djQTlzUZ9hN9PWZEVj1gOwRQT8zIBv1Ql6W7auTqi6abTox3sB+AddFVU7qELGQrVQ5NYgebVO27vIhtZgHrtfq2xHKP0P9/PziujsodFX9ARXbcE3Id1Ia1j2sq/x9DqP/rui7hvwf286y+ydMn5j9E6o9Uv5uz9r09+kp3zTJr7J7l7hvhHsrQm9vccxq5Tfsj6gn+jkfPNvKF7gfPwJYyhceLu5rRD+9OJ1e+aOyeSgezxb06o3nYTcxxsymNOQLxd9Ee7uGlT9ifmL28yA922auoOd9WfnVIHq0k9oVbTLV/MpM0P3EWePpuP1Tf01XfsZ1B8uRD3SelVAO+gSvD2N9wXHf0gVjPGgvXz15W3FfI/rzF4zxHVfcq71ns4jf0k6Aenb5Cj+/2VLVEe7PhPZUqnwi/cOefJ4Gel4ZmFsxvdqsd42y9U7tiwvVu1Z7Ks0mak9lTP8U/dsXkwdcOB5yTF4FZcBzK9ifmU26D5XUXbUnreLI5wolh0kHFc9Ue6DKSrXBsz1YfU6vrbyN6OeD3H6ByfTmEzi/OZ9oLB3p10JZXbNCYzqPDjM9Og946OeRDka/QfhLKA6g/88lTKO/HDCPLYn5Dg/mlYG+hqqnob3SCwQ9lpfpo/x0AaWh7twuzgf5TPtuko9p6Ocs1wX0VW1qSF9ubyztTdBe3VTcDxJeyVjdHyqr+4S+sWU1M5A/xjI+3PsQU0fQHpsWaMwpJTHvEG266qusAPw3efojzulxDcdldRA59nNU32CE9Lc25F5RHzvXx86+UvZtYGWb0NvAoT650eSXam9OpzTV78qEDmXbUnx/4mdGxuPOCuDmf68lPVr18e4s7jkOvzsQh5UNQzZvNa7heQYsj7mUpnx2sv0x9D5PKK/5FfMOB596lV/qHQ7u26E/cj8r5Df5FfLHWZDX56hvN1fIVDG6Qfq06nNndG8xfsBDzzHf6PcF+j0LhQ4hPz5K0C8kGsw/tktHOS0b6yXaZAPlx+ifi4zHVi5tjr3k97vRbuz/IRvlF9t0kaBHW/HHCRdB2gJKQ59fSGnof+xnqs7G1g3jze1wH8XqRiRuJrDU/DvHaqP/QCBWq/gS8vHY9wtV/Z9PachnZaN81eg64auYH/bVUJ8zv9g2Kl5w3zO/Gm5ibJhLaeir+NFQ9i9cQ9hI/tWpvo9qazm2Ix+/L1h2TK9Oj1RyGm3KCc2JIl/m+Wty+BnLUTpbfuYE8qPKZ05kfuZQfuYkzI/SudWc6n+hMYyKbcjL7Z3R/x8Yk/1eYE41tDYQ8l3fe+ZqDim/rnJj+XduvP0MtxPrvNhGxcx3In3ZGG82qDrfib6HbafRONKxE/ZKuS7T6j1rXvsOzR2jv3HsTTX/etpIa/1D75W38g+ei4ntA2DMNWznXll9APaFUB8Ay5/nkVWfVMVLLmOMr1guvGZl9P+v5HxryG9azeHxWF7N4YXGlZM9zukWv+F5X9V3jPWb0FwhttHWfofWoTM3vp30rfP0e3BmE05Gz6fBc+R7kHThPhJjv4XoLZ8DHnrD475IvSgUNZcwt4UObyUd5rXQgddcjH6G0CFk//wK9QkH3cS6WKLeRJ+tYPh1p/2j6aKujO1n8pQf5BfXZVWfMI3bZBUDVT0PnbeTAis0R8pnK5QdFyF/aPy1uk05q4WcTo+/+GyFeQnlYJ1ZTXLmJ5SDWHy2Aq8Xqr+xcrA9it07c9rCMR5st3zjPH5nwugfPmqM74zioRoz83zLQsBzgn6lR95ZxY3FP5xzLBGP5HtRhtXKdueQ7dQZZyHbGf2NYLtzA7bjuq36GMNuoj24T49zsDz/reZz8Rn7HPIb3ZDg4/ZqMTwvM1aMqRuIX3cT81ylvVpM8jDv+cXvmyypJu/Q+yZNIU+VA75vgjZF+YbFZyuo/oaKjYsoDdu1oygN6/cKuEcZvjxZ3za070j1Q7HvpuZb2Pcmu680t5q8YF9JzQ+V7SvxmKBb+0qoJ/eVys65Iv+cgJzVbcpZLeR0em6311eKl1Olr3R/or7SPy0c43sLtfcYK2L6SnNFPlje27qgr/QOsl2r9QS2ndH/Cdju3QHbcd3u9ZXG9MRniN/rK41hcV9J9Tc62Vea2yJP3FdS+qn+jnPx9T2mL4X5K1F2S2N90/BT9aVUv0T1pdrcR9vMfW1awYf92E1wj7ZDOfNIh3bLT83NHK7ym11NXrD81JxVyvLDulWm/I60PQMfpDZerWmF9gwY/Segjf95auNxvSNmX0AH1/n7u3lvKa9H4bo1j/tSrVtP8axbZ4D7NsHLdRvp5wk9jJ73lDIN7+k3+l+DNZjlnv12al8n6s8++xuAyeuwaq0xtL+j1VpjaI1+IaUhX2gd1ujarBNLD/d+U/Z77MvyvlGuX/m1QWCFdJ3dhq5cjlhWiwgL319RezrYL43+vwu/VOVvNu9E+YfW4ZVNQ+vwrWzK812x+415HV7F3th1eIwhH5zkMSrPGSwGXfqFroZbI/qvQhv8HWrXbbzkXFydbQp6HHPxfiQcmzUjsEKxdKmgbwZko17Iy7JZT+PrYN2S++RwrM11S5UT0sfYSpVTg+jRNmXHy4spLXa8vAjy/B3P3BLmo8oeGp6zUrEq5HuxbZWq/4soDfk4bqg2TtUljhtYthw3msVv9FWk57nGQ/SFojb+Qh8p4etyrnEp6bgEdFD+zXOIRn8UrLdOPUpjTimJOa3AadXOWjl24lw3rO8cC5qQ1i/oy8ZNrrdYNjxPqvqzaFPu15uNBgQ94tWIfi6UAZ+pgPFoCekeO3/H7ySpNYTc7qsKPYbcxLiB4+XF5HsY0/oFL/ue0b8W/HlJcZ8ybvDeTowD3E9VbY7yM9U/wzaU+SwOWFxpwvNOzIk3i/u6m5jnKvNWTZKHec8vnrdaWk3eoTnxY4U8VQ44J94EmSjfsELnVXYyrqGdYuKamidvuIl55PqMMYLjAMYIjh/zA/IwRmBffBXVfRUjY/ssuA55P403sH5x/cc6zvUf/Z37DU1I437DUtBF9XmwzUb6iyCGXUe2Ub4c6scuE/THAs1RlB/09WURWIsCso8T9MsCslEv5GXZvjqp6qLZphPjjaVIALi+ckL6GFupcmoQPdqmbN1dSmnYvnO9Rt9uurE8X+dptzEf2G5z3T1K6Ir9gcna+5dqruBWqLtv9fSnneuOuYLQfPtSQd8MyO7NFYynrzpXELsPMcVcAfunWn+LbXdxv+85EXMFId/r1FwBx41umisYfRnMFTwHsW1HormCnb25gkNph2uuYH9grgDjUafnCj4WOVfw3kRzBZ8Af34hMFdQNW705gp6cwUvghd/X6lzBRgjOj1X8LEOzRWcFpgr4PrfTXMFvw4x7L/35gomyPbVyd5cQbm6u5TSqswV/PcOzRVwf4D3WuXXDfCMv/U2WXut/hj6WcsDZ+Ksh7x92ZM339kYfHag0f8TxIn/TX0ddR7wsJtoGz7bfgHowrSbnbbBX4AeXz3KL4v3c6o85hh/dZSfbrOgYwx1zjGv0Y8IvtAeFkeYfYI2dIbavICM2YSp9t3mF88v+dLVXjonnvUJ+nme/Dohe34L3LkCJ3S2jDpvLeb8EPxmEMcXjAu49+H+otMQOo/afi+gfM0L5GuW4ON6jrrPDeiu7IfxI3TmrP1m35ol8pmJ36bfXfCMY6z5N45NkcZ4+X3wKUWgV/tT1TvmqNebPJiDgHli4OwTwzwTnpXdlxx6f3Me8alz3px4pspniGh5b/RmoZPvt+99YqWDOjux6hm+sXUTz/B9PdVNfCdgmHSfSbojLb+LgL+Vf2d0r759gTTs30Z/VMC/1TeOUK83eTCPDvi3svur4VnZbxzxmZDqG0dKd4w9/EyVD/s3x6PNQiff7xGB49NhpsAx/x72YLJM9of8Cr1HgOekfrX4Efo+DvsLysRnPIc0KPTn77edDr7E38VAPVUeN3gwVwT8U+UhdA7srECeUZ/QN+EUH5bfoJDVtJvvhy/Ds7ow1fl9kM+tfw3YacUKrUvG+rS4Qt/DGiT5FvuaLupqog/bpeYIDb/uJtqiyhyhilHK7y1/Fc/rWoLvwaEfbYJ737lxVl6t3htbs2iMx1fHMCZtKe65jm1YNMZ3iQfTufZi02cb43FDdTG/yrYtvM6HNg+dkdtHaVgmvn4p2hfp+Zxyo78a6uaVnf+WyD8c7vfr+PsMoe8hKP/Csub5FLOR7ztQhlcj+lugDELfZOd19OGSusfOJ2Pd4Ho8LHDVd1xD9R71vra453q/JdC2lv3eqmqLMb+mj6qfPI+kvtOq6ovRdeIMVMxPzPdW24ldpr+aw+B+JL6Pit+BQRy0d677Ryj2bgM6XnfOL/av7cVv3xym8daI/u1ivGL5wO+Bb6N8bAddzOesPd5Bujdd1NWH7ZJdqr9h+HXSpaS8Q/2NHSSP82e+kn/z2Xzi4a1333v31nde/sCmO9ZsevChh+/d0ofQoAVLyQgVn2VufO4xrZ+eTSO619Hv9YLPCWyMHI9CmrIEn8yBeXrUw8eey8/6BP0Owtoh+Ez3/gA/YiAfewzXIozS24RsrkVPQC26boVf7jbnJtiBa9KgkGe17lGidW6s1j1GeWq6qOuG2Fpn+HXSpWqte4zkcf6q1Tr0FJRyPaEaDdLidT1ohvTT6DeX3pDg48ssViOdfxL6+AeKe1XTTiG9lbfjM54nQH6jU3KObVPOsUKOefLJkMZnlJ0WSMN32E+htEtBFz5f7TLg4288bxR5trRHApijAjMvu9WLx57n/3YDhvJ0jqpPAS7y4u8pgnZzcV8j2o+BX32A/AprMfvVoy30DvnVo84v59g25Rwr5FiZoP+y7zwm8mppO0Eel/PjwMe+84TIl6U9GcDcJTBf3Gu7eDwdl39+WcTfA89LRODrYyO+4ddJl6oRfw/J4/zxvM7T1eRdlxE/ykNM08dsvVekGda+4veAB8t4a0T/qaK+NYSMo0mGpaG++Mzsk/vJry0arzvaNvP8NVx+xvUL827lY3KeAj6c5/odGh9jnOp3E2MV738y+tOXjfF9lmIV8nPZqXpSNf+7RR6H3UTbLIV7n3/vCchZGshPp8pzKcnBOIvl+T+pPJ+GNI7R+f0VxX2N6OdDeX6RylPVRWVnbpfK2vkUIafTdub2ZW9COYiFfZf8337CYjtbOZmd90HafuI7AGlIh6Ou/fD8gJCt8A2jlQ9+bZHOm88HTVaN6L937Bjf31b0wb2UhnEc20XUA+2A9Fc4na8BD70vX98U86XclqCtsCw4/hr9dwLzjcq3sD3gOTXlD/tFvpRND7jWstHO6z2yB1zYF2tE/6+BOejdgl/VozNIl30tdOf6jfxGNyT42o0jSudWdXKAxjat6uR1xT377p9DnawXmMOutY+gzjyOKGvnY4WcTtuZxwgHEspBLG4XniEstrOVk9n5IKQ9Q3zPQhrSYbvwDDx/VshW+LHtwlGLdd58PmiyakT/u+CDR5MPqnZF+eABSkObcrvQKh5eR/Sm94ALt7c1oj+uyItqF1R9xVjL7YLRnwCY3C6YXMxXqF1QvnhQ5EvZ9BnCekpgoZ25XVA2xfw/Rfk3+tOFTVW7YPxqPmIFpeF8xNOUthPSuM+K8xF7KQ3nI3hu5ElI43iH8xHoIzwfcXIgPzhvx/N9OG/3GKVdCmk7KQ3n7R6nNIxxT1DaI5D2JKWNQtouyKvN29Uor2uK522ub8l3eX3zokyHf52Law+wrKaRnB0J5SDWWpLzaEI5jwbys1PIsfLC+tKJ9UjDr7uJdbfKPNnjJI/zV21lBKMNWwVR8Vnmxuce00IrI/mVYj3yCUhTluCZc8zTEx4+tIUTz/oE/eOE9bjgM937A/yIgXzsMRk9961HGkaN6G+B1upGaq2VLLQHt5imu29nAetg9LeBDrwT+nHgUfna6cF8aPGYPTYv1phOYKp8PUH5Yh0eJx2M/k7RE+gnGtZHPct/41rvEx79VDmxrtjK+fLD5WT09wXK6TGhA9bJ9S10YJonPDq8ReggotuaBx58ZxHdHF01uOdopCzP67aPCRzfZdbIvdA8Us217RR83E6hBxhvnnPb41bk/OIt927ZusWTd47c0zwy+5y+YtpQnJvpRBtq+KnaULWWotpQHu8jrxq/Y/ni71Zy8jK1PWNFmV679YG3+oo0tnHNhFrM7wgrE8/ya8hNzNLhdoOKS4BBN8D8VetKoXOyVRAVn4Us36q019LvKl0pNTn2tMBUk7H7PHytglyfoN9LWHsFn+keWmhFDORjj+Ea4utKcZfD6PdC02Rbu5jHft8N983iPrQAZLWKF1eaLuoaia1Vhl93bdXiLORLaqG6XK3i0GpSZhKq0SAtXjNBM6T3NYt2bRB8fJnFYprMiqU6rWqptttkqlINNZlqmr4h0nibg1rK2S/k9LB6WGWwOHL/GgwWf5Gm91ULxi0F6vJ0QBfV+vA2+fw+tB2Nt5XFbjnjtCcDabsCabi1hqdg1XYY3j6BmC8u0Rw9ni7FcpqVj1pGwdaHezJqycSwDrbAuoqwkP8gYT3TAusawvItgeX/nm2BdTVhqeU2w3ougJXfv5mwkN941VDI+IaEHG4Ln4fnJdqm6TE+gvh10qVqW/g8yeP8cVv4XqFLQ6Rx3HuvkPNeIaeH1cM6XFjm41gnqsbwhpsYD54jOdjW4rL/X9KE73OQpkaK9xT3NaL/6LFjfH9N/QKMG6bjsNCZ+wwqXjwfyP9OIafTduZ2fWdCOWr7vNnmfYTFdrZyMjujD76P+N4PaUiHswXvg+fvF7IVvmG08sF/Wazz5vNBk1Uj+veCD/5boG/KPoh220lp6FPYTvv8E+nvIXrTe8BD/zzly+inFEFDbT1Ri1moFx8vYvSDgMlbT1R8UzMRIV9Ubbey6fsIS81EYX54cUTZFOsnv0Jg9A1hU9Uf460gOPYIbT3ZT2k49jhAaTj2OEhpOPZ4htJw7PEspeHYg8dPuLWG2wkce6Bv2diDX9I8ung+6CaWbYk+otzGwXURbY9bXzDNuTE/UK8bNwT/9oCcjW3K2SjkDAk+y3ebdoxeEzD8VK977yR5PrtwW4C8DZHGC6y2HeqnCr/LffNUGhc3UcHir9kVt++UyOfZsXY1/DrpUtWuJ5M8zh/b9TShS0OkXQX3mIZyThNyFNZIQqxzE2LNSYi1MCHWvC7NY8pyTJnHo7o0j7MSYq1KiLUsIdZwQqzlCbFmJ8RK6RMp62PKOpTSJ1Laa25CrPkJsVLafmZCrJS2byTESmmvlLFwQUKslPbq1liY0l4pY86R0GdK6RMp2+2Utj8uIVZKv09p++MTYqW0fco8powTKfsAKe11QkKsk4p7m2PCeYjtJEeN+U8OyEH+kyOwmgIrlEc1jzPdjbWHh7ZT3/7wnZc/cKeji3d/X+xR8SyiW+9RLRO4Gf3j52fRs35Bi9j5tNLBIn8d3MK7MiM85/S00uHawlt2J/f1cI9pKCf09jhijSTEmpUQa1VCrGUJsYYTYi1PiDU7IVZKn5iTEGteQqyUPpHSXnMTYqW018yEWCntdW5CrJS+ujAh1pFQjo2EWCntlbIdWpAQK6W9urUdSmmvlPE+pX+ljDkp62NKn0jZZ0pp++MSYqX0+5S2Pz4hVkrbp8xjyjjRrf2vExJi8TTJXkjbTnLUGHZvQA7y743AUuPhUB47PE1iKq4guvUe1TKBm9E/fr6CnrWaJuFdObOOeemvTYtU3FUkd4PxLi2cDsLdbpjmXNxMHfKfFpCzoU05G4ScIcFn+W7TjtFvehh+3U3Mc5Xppe0kz2cXtRvMeNVuMN6JX/atsh5WD2uysUK7PWPqp5KD8SAmjlSVg1h8aDfmleNvWbup3cqMhTvccWc9Hwhp7WTNg7kS0pH+gqLtyneE30wfxVJvYrx4uN0xrXXdKXTlt2rfdewY35oCU9mZY+N2kUcuO5SrMLlNK1t2G4QOISwsr0uJ3spiwENveFx2V0DZ8RsS6tD8ewI6K/9BHXz+c3UF/7n2mNa6ov9cSrKN/hbwn+vJf5A/5D+8Cxv9x2yk+kS8Q75snwj5Q32vRylN6Z5RGuqwPaCDslHMLv2Kn2v6VEw8RvxUu/RbfYrM7GL5q/hxkt9kf0Z5iPkoyau4jNqvTs/Assn/qcPL1eHjfHj5Q0V9UkuhxqOGstyXaGdY3Ems0CkRWCZ5bLmbbNGpg0i5DnZCTn5xnwZ1uBXufXUn9EEl5A99uGljm3I2Cjn9Qg5+dEudQsGxrWJdrMXGNt7S0O6HkNQUjvoQUtktDRxH2ql7pyXE4qMtld/cKrDK2ivhFJapeD3RXeNRrV/gZvSPn19Pz3xTWIatquROj97OxVVJ5J/sqh8KmW0269FV2/BTfdVSdSOUXfhYOORtiLSq3wqbLKwOhukpr7Qw/XLpbrWD9UPFvVodmUFyyvof8u8NyHm0TTmPRsrZ3aac3UdAfvhbD/mF0wv/6RgtE6cXcArGuog8tfHupWN8v0nTC8jP7f2lIo+XBvKI/Ean5GxvU872SDnT25QzXcgJYV0ssIz+EUE/XdAn7K6ZiqcQ3XqPapnAzegfPz+FnrVacTyc7tAJOVbVbOX1heZLf/Oq9oc02kYXMHtYN2AUnpdoll+dEZ7lBZ8hft1NLPMq3YBRksf5427Ao0IXFYIvh3tMQzmhLjVizU6INT8h1lEJsUYSYi1KiDWcEKvRpXotTIg1LyHWCQmxTkyIdVJCrJT2mpMQK2V9XJ4QK6Xfp4yFKctxZkKslOWYMn6ltNeqhFgLEmKltFfKOpSyP5HSXssSYvXi6uGLqyltf1xCrJR+n9L2xyfESmn7lHlMGSfmJsTq1v7qGxJi8Wb2UUjbTnJGhZzRgBzkN7ohwZcVf9vcsdKfEZ7pic8Qv+4m5jnVjpVReMbzBLuELg2RxtPyu4ScXUKOwnqMsJTOam4jI/5WeezASuxKorvKo1qfwM3oHz9fSc98U3uGbdUEp5Z4Y6maBVWmbQj+RwJydrYpZ2eknA1tytkQKWdjm3I2RsrZ3qac7UJOB6c7h2LD2GhxP9nTnW2G6ekxzZZqMh4TaRwaBzxYfESv0d9VfPa+IWRw+FUhEJ+ZfV78Ru2S8XSjgIUbjlutjt2zZLzeFq9+dskYzX3FvdqQaufWqCN9dgR0YF/Gr7GXKOvoo54Nv066VPXly0ge5w+bq/gP1XFkRKsgKj7L3PjcY1o/PePXIk4mviqff9wIacoS/NEkzNNGDx/awolnfYL+MsK6TPCZ7v0BfsRAPvaYjJ77Pv/IHx8w+keKWqW+pK1koT148dF0930dmXUw+h2gA3+h+TLgUfni2ryRfmMk2OyR/16IMo8v0fKdkM/5w5bE95Xqy0gHo38KbMBf3X5E8DvPM7QB8vp+I23Tjc8L/la+uI3oR4vfvrxz+Rv9gUD5bxA6NN3Ytb6FDkzT9OjwnNChvS90c5TjUuKS2CBwfJdZI/fY91Ib3ASaSwXfBvqtPKDdL3Sf5pHZ5/Q15LRu+TXo2moro9tmw6877XlNF3VlHD1NHuePh8uXCV0aIq0J91wbQnLa/EK3r9FWwYL5HfFm4ll+4VF/1lBjV5WHoLFdVTUENTolZ2ebcnZGytnQppwNkXI2tilnY6Sc7W3K2S7kMJZvw9wdxX2N6D8BgZ2/roRTKqrTyJvh1ebn7SI/Rt/qnUu2Jc5kPR0hG23JDeHekrqqzbBq06R6b3VfSV2vmmRdHxO6DgnZ3ORgvjrR5Bh+d3+3nLfL8qkmKYeD+XUJ/a4yHFRv0u0VmOYh6k3CkGc58axP0O8jrH2Cz3TvD/Ajhtp+bBiKL//9LsETqgExHpxf3InZnxDrgMCymonfFi5RU+bG1kzDr5MuVWum+g4z5o/z/ozQpSHS+C029Y3mZ4QchfV4QqwnEmI9mRBrV0Kso3tYPaweVg8rEsvSsM0+QGn4tv+bi3s1OuARatk1c+TfFZDzSJtyHhFyhgRf5vlrcvhZaA8AL5Ji2812OyDycyAgB/n527G40Lex+JuPVmc1tUwcyeIiHn/X2+h3N8f45jb9eUQ7W75Y50GQYWllFm/z0fQ5dLIO9nGmAK6v/mAf7j3Fvao/o5SGZc3f6PWVwZLmeH12QZoqA9OHF1Ifbo7xHVvcq9fJsR776o2Sxz7iW+jdRfoZ/QnNl/7iMoLSb69HHtoD7fwjHnmnNMfknQj+YPl0JLtNv5ur/A7rK/tdbL871k/NJspPecZGLfyjH/CMjfEPOF0Ghlcj+rObL/1VJ2618nMuV6N/DWCGyjVRPJHlirbiclUza6odCvkBlhfvT8My981EIhaWdUy5hjZtGP3FzZf+qnI1fixX1JPL1ejXAWaoXM2WnShXtFVMuao9nqH2W32zuuEmtpOXEZaK0aEZVlWuWAYco43+muZLf1W5qlnuUBw2+usA83DFYbRVTLmqlYDYcuU4jOW6h9KwrYvZH9qJGL2p+dJfLHPV5380Qj9lt8SLe/s8aswR/I54M3oW8+oITquyyS27vsPi2ORGf1fzpb9qR8Vjgj+/Yk7sweLuxKKA4ac6sSfU9XxRseIvn3CjqplavOJyaiUnoavm1yUeNTLB7wgrE88wTbkqrg+aq/LWQm6h76Gti+hCPFJQkU/1/I3eeqC+3oXh1Yj+Xc2X/qpWKNQLzi+O1s8KeuwZmz4q/89SGvLt9cjB1hEjP7eORr+tOZbXUOtosjvROqKNuHV8DtL6BT3b+3lB/xzQ8KzS85DGVRpt/CzJaRU62P+Vn6rRt+qN7wzkt9WojP0LfeIZSlOjOeULRteJmRLMD/tCqC7lF9sm5DtomwbRKz/BevkMyQnFpfwK+QLOLths2CBgo5ymi7pOMP6+avy3G39/Nf7TLJ+87S+/DBvLtoTPbEab2KW6CoZfJ12qdhWmkDzOH3cVBoQuDZHGXboBIWdAyFFY8xJirUqItSAhViMh1vKEWLMTYqW017KEWCn9a05CrJGEWCl9YjghVpYQa35CrJQ+cVRCrJQ+MSshVsq4mrJup/TVbo2rKX0iZfxKWYdS+kRKe81NiJXSXgsTYqX01ZR69drtw2evlP3VlDE6ZR/g3IRYKeNXt/pEyjjRre1QyjFMyjwuTojVi6uvjPiVshz7EmKltFe3xpxu7RfOTIiVsj6mbGtTlmO39lf7u1SvlHH1+IRYKeNEt8bolHqltH23xomUffIjYVybst1e1KV6pRzXpizHlPUx5Rgm5bxvSqyUPsF1KCt+49rrSrhfAelIbx/yUevYJdZu7xgCHgcYiF1xHfqOjPCcG9/XcIQ/5JGXX3WRVovQ5clf+q0XLv/6Z7+WEb/pws9ixiZqTdtsNZV0b7qo63a1h8RkWxr6yBRKQ7uYDvnfk0m/gYr6xdgP8Rsijd+Kiy2LETfeF9Dfh91E/99JcvqEnD4hR72lFZKzsU05G4Ucxoo9r8ToH1360l/eq8a6ZJ6/pjs/Y91RX34zr1NyTgM+TsN9lTExreJel+gPZxp+3U303RLyDu2tqZE8zh/vreE4mV+qTj4A92XqpMIaTYgVqne8y71svXs0Us7uNuXsFnI6XUceJTm1hHKwzuwmOVMSykGsjSRnIKEcbAtXkpxM6JDr9fNLx3iwrcU4jbx2BlSN6P916Rjfh4t780HVB2B5HL84HyzvlwsZFv8Gib/p4i4cfzvCamW7j5Ht+iEtxnZG/xWw3SfIdqgX1220U43SsN82hdLYVpgHS3OQB3zGPof8bDfk4/aqTjo0XdQV/XFgw6+7tvzjUHtVJ3mY9/zifvO0avJqJm+6kKfKYabTNkX5hsXtJvfRMA3r4yClqb65ikE21lO+zB8F5vLkZ+x3zK+wyo5Bv0IxpeIY9OQO9tdOjvV/wx/yyMsvtU86Zgz6qZUj53zmvN//ckb8pgs/Yz9T/agZgr7NMd6JagzK40zOO6apcaAag1acTzgxxn6Ir+omj0FjyyJmDBpKw/aF255BobulYYzivoDFLNV+Im6N6P9y6RjfPy8dj6ni6FR4xr45JOj5Y8uYH4yzQxFY/QHZw4J+KCAb9UJelu1rD1T9MNu0+Z7PFPWezzQkAFxfOSF9jK1UOTWIHm2j2sF+SsP8T6M0zAO3kejbdcgz+2e/yEcGz/g9okzoqvqiqh8X8j3VvxkkmvxS9b9OacjHcQPrP8cN9FGOG1i2HDdULEd6HkMY/eCxxV830UfaHUPwHDv2wZR/89jA6I8pdMztMf1YjTmlJOZwgdPq/U8rxzZjQU3FAqzvHAtCMTi/ysZNrrdYNlMJa6rAQpvyu1tmmwFBj3g1ol8IZcAnIGD+ppPuWAZ1Sovtl1t9yOnPK/RQYzYc6zbJ9zCmqfEJ+57R/xD487LiPmXcGKA0jAOIwT4V8rOG4Mc2lPksDlhcQV/sxFjX8OtuYp6rjHVV/cP2gfvnFePmobFuQ8hT5YBjXbQpyjcs7stPVlxDO8XENaS32NJwE/PI9RljBMcB1Q6quUiWhzEC++LnUd1XMTITuKrPgvOLNveo6jjXf6zjXP/R37nfgDbkfsMw6KL6PNhmI/0lEMNeT7ZRvhzqx84U9LjPYpDyg74+MwKrHpA9IuhnBmSjXsjLsn11UtVFs00nxhvYL+C6qMoJ6WNspcqpQfRom7J1d5jSMA9cr9G3cf7i9Z52G/OB7TbX3UGhK/YHzDdwbWi7G5+2F9L4hO5W3y7gtW87H2bAQ294NaK/XfS3hokmv9/gkYf64TPuIyD/fg8WxhvM37Ue3e8S/XXDVOdQqM/dGH3oBEjUR9nmoNOyMT94VJbv5Nb7I8cf5lNtxobph/uUTLNJg+jRvpa2HdL4PBKsO3tJB/WNkZ3wjOs1+p3x5na49piX7tV3TbqxXo9G1uunPPJQv1C9Rv6y9fpej+47S9brp4R+3VSvd0fWa/OpXr1uXa/VSZGx9dp4czusPmY87vsgrd9NrOtcxkb/QsBn3y90xfOY2L4vCPr3C/2HSQfkHRZ8z1PaC5DGcedH3UQ7ID3XXaP/abDDlQFfN73a9PVpytd/FAjY138M0voFPZfFvxP0PwY0ZpMG0XO54G/EwrLmOTSz0YDTZWB4NaL/SGAODc94+1HSfWdJ3Z8Wug+5iXUG69S/FC+dmg/iOWN8nOh7AzKZF+UMeOgNj+vuJ4W9MpKB9QD14o+VGv2vBuKBsuVeeMY+qOLH+0S+lE3fT2nvhTTzBVU/ja4TbRHmn+tnKK/5VTVWNtzE+vMcpWHdYP9X5+fF+j/60F8uHo/7DKQZ7qPAe11xz+dyfi7gX+psQNWHC+VNnQ2ozt58jtKQbx+lqTMFTYfnhR2Q/g433g5G/z8j2xvTq01/vlD5M56zyf6sYhjSc1mo2IB1ln0W/ZTPYlT9NCxrbm/MRgNOl4Hh8bmpXwm0NxjTnyfdD5TUPfYcSaxTR1F7g/173vfb6kxdHt9Yn3fAQ89n6hr9XwfaGzVmQjstIUyj/3ogHqj+fWjM1Kp/b/oom/I5qqg7flPTsBmzzfp5UcovzuQX2yb2DOOGmxgPeeyDdYPHmmocHuv/6EMDizWur725orhn//p+yTE5to1lx+Tc3qgxufKvPZSGNuXxo2p3kZ7nHI1+6rLirwu3N4n8edbhPheYvyqJ7YFvvgexsKy5vVFfLzoo8Hk+ZRaUAbc3e4D/GdJ9b0ndq9S3rxUvKat5Qm5v9gZkMi/GC197Y3g1ol8s7JWRDKwHaCdub4x+CWByPFBznKH2Rtl+n8iXsul+SkPdzRdU/TS6NuvnbFU/Mf9cP0N5zS+2jYqt6ksgqk/FYx+sGzzWbvVFnZD/ow/9z0XjcXn+HbHQL0L+iPUG97Qh/cqAP4bqWX6xzVN841yt/4X8MdGazvXKHzH/7I+x3wKPratWng030VdD/hizboMxhP0R/QjXbX5n0Xg6XAPMir+2dwbfuy1h8+hPthh+nXQpKe/QfqRLSR7nz8qu3HfcecUKrYKo+Cxz43OPaf30bBrRraXfVb7jfhmkKUvwd9wxT5d5+NAWTjzrE/SXEtalgs907w/wIwbyscdk9Byj5hIhu0b0V0PUvG6FX+4SN9EOS+j33UJeB2vdyJFR62YSqtEgLV4zQTOkn0a/uUQ3CD6+zGI10vmNhRfl3ndzcW8l3wRefvf2ZEiz93VyjAOEwZ8dU39Rd3zG7VeKSKHWJ99MfPjVwBsjdLhM6NwQ/EY3JPiq2qYR0NnkoL/g/ud7lo3xZJSmIhGvnxr9/wYfur+4N1tijTUdlZ1vduN1KWvnm4WcTtv5ZpKzMaEcxOIzTEYJi+1s5WR2xi90jxLfNkhDOmzlRuH5NiFb4RtGKx98ZJnOm88HTVaN6H8LfHA7+aBqTbn1dS7s8+yXAx56XlM0+scD4/glIs+oF2Ma/a7AuGmJyJeKlaF8oU8t8eTr6cB8juqFqLZlBaVh22IxHNuWGmE8WzwfdBPLo0QvQb7z5NMb6UzuadXkRo9BDL/uJtqwSm/oNJLH+avWG0Lrs1UQFZ9lbnzuMa3VGOQK+l1lDKKiQFNgWkRR/Xrm41rIz/oEPZ+epGoQR2fFjxjI1yQMxZf/HhI8MTWgYv+8P7YGGH6qGtCq3PlEoEuFLg2Rhm92YBrKuVTIUVgnE9bJkTq3+RFWHnSc5lGjT/A74uWqzR37JunBVWe9R7avETa8GtH/smisQvz5FeP2WESdCPyGn8rtY12IB3HIG2rkMzexDCfJVfPrCo8aqkVxhJWJZ/ml+pL8LnnTjdexU278qUCfa1Dw532nNzbGyx6FtJixntH/TqDPuc1NzH/ovY3tgn4b0Jg+w6QD8g4LPh5n4j5lHkvtcBPtgPT3uvF2MPr/CnYIrSWbXp3YK7sDCHhtANdI+gU9l8Vjgh7XicwmDaLncsHfiIVlzfXAbDTgdBkYXo3o/zhQD3CcvoN031hSd1WHeVzLdeoRGoOiTG5KHwnIVD47Wvz2xQ3fGPmrgTGomvtBvXgMavR/EYgHo25ivkLxYJugHxX5UjbdRmk4J4HzQYbNmJ3YKzsKBFw/Q3nNr6qxUr2bsZHSsG6MkpyNQk6s/4fmFjFeGK56R9PobT+7+TjT8LlJRv9P4I/LKSagro9RPvD9k6z4a927x0n3pou6ort3hl8nXUrKO9S9e5zkcf6qjeu5t4NWQVR8lrnxuce0Vr24NfS7yrj+CUhTluBxPebpCQ8fey4/6xP0jxPW44LPdO8P8CMG8rHHcC3CqP6YkM21aNpxL/1Va4soF3sNrIv93iDkWa17gmidG6t1T1Kemi7qujG21hl+nXSpWuueJHmcv2q1Dj0FpdxAqEaDtHjdAJohPQ/zd9LvSwUfX2axGum8rPCi3PvmFPfDbqLHLiW9UYdQ/GoIfn4nFOUc26acY4UcPiMlv+e10iGRV0vDPhafozwKfEdT2jaRL0vbHsDcEcB8VKTlZfdzx42nw2iUef7mV794xjZ9XOhqZYcRoAn3vtr2ZEAO8hvdkOBrNz9KZ9XHwL7S6ceN8eT/dkGaag2s/1Zj+hVjfCuovu0CftNR2XmpG69LWTsvFXI6bWeuU08llINYPA7bQ1hsZ56H2A1pe4jPt9cYewS4507t+VT4htHKBy86TufN54Mmq0b0f33GGN/aij74FKXh/kBuD0N7DbEMOF8DHnpfvi6HHhHPNTwu+JXuPO5/KqB7frEvIr/RddLnUWYr/7mO/Af3cSr/Md4a0X8e/OdG8h/soXUi/6F6jT05HjWoeqfiB/NhHT0jQoc9QueG4Me9yszXrm8onVv5xpvIN9Q+cfQNfm/W6H8NfONu8g2Mn/wuEerMfcCydj5WyOm0nbl/tzehHMTi9k3tF0c7WzmZnXEv+X7iU+8ScvuG+83VuxMKP7Z9e9dxOm8+H/SdzfOT4IPvCYxpQj4YeieG36lQ7z+oMshIb985Cr73jB4V7VuovuKef47lRv84YMa8Z6RGyyFfLPueUUg22nm9R3bZc5yeDtjU+H3nEbFNjX5/wKbKRiGbtno/id+HwTzzGQBqpg3tHGNTzP8TlH+jf2+gH/aU4Fd9B+5Dqn4Y0nNcVHVM9U24jv27yD4k921wboH3yuHcAn/jDddAeCw2Cmm7KW0bpPE8B64rcPu3A9KepjScW0Dft7mFGuX1F4rnbc7Byz19j5NueH5k5vnrXFx7qr5X08l5EyXniYRyEGtN8VeN2XiXUtl5A+QPjQ2H2pQzJOQwlsXk/MK6z+uqRv+foF4fSzF5l5uo3xA8Wx/IK9dnxLIys/qBsa8Ta1SGXyddSsrLQjEX88dbkHYLXRoizVemKOdkIaesXtPd2Fm5xSz+xVtuf/jOyx+409FVo98Xe1RcRHTrPaplAjejf/x8ET3rF7SIPVlV73DKOaVNOacIOZ2e6jyF5PiGO18oOaXMR2YY/V4Y7nwpMNzxVTv0NVzqYN82eb7l/kc8+v0phN7lFHofEXm+NqDzLpDBcvP7lR4d/i91VSqGYtlV4alQ1KdOadj14CMhsYvTL56xz+0UchjL10yaXblL9zclm8nQQj3qtIvSsGliOyg5KrwrO4TknNqmnFOFnFCzXzWWKJ15KJFfGEu+S7HkKUhTXZoNxd8a0b8HYsm/BGIJ6si/VVz2tZO+WPKkRz+3/KU/KpaoruGGgM44BGS5KpYcsmmhg8USXgpqurhLxRJemkB9XkX6l20LkX+y2sJXkZxOL/up6X6OL2o5andAjlpSa1UfZy/XMlV95HYN6ddCfZy3fHweVdses1TX6djLWLFtkNEfA3W83TboyQj9am5incrvT4c8+7CceGb02P7x9MVTRLsrQOuLW/n97cV9p5cYNxf3qn69mvQrW7+QP7Z+nVayfr2puOf6dQbUrzOofuFyANuVlwCQdjPRPg35jsWdQrz5/dFEu4dw0Sd5ec5wX1g+hn9OcT9Esgxf/c2vGN9Bvdl3cIr6TLjHNJPDz1gO8hudqgvoOz+0XMtE38HyZd8x+p1gy4uW+/PI06wp7GzP98FzlstLkPuJFqfyeZp4H/Gqv610VMdw7ifcAwH9eZn+acHXyeVW1HfIaf3V31g5iHU9yfH57kbyXfXJDPTd+4t7PuLxZvDdG8h3kZ99F2Mqb6FU0385/m+QzngEpdnpBsFr9M8QPWLkV6tjlpnGeGtEf5sYW1jeDgh5ed5u9+TNd7wwH/Fs9KNQHluoPNBeVh7qqHCuA8+CLky72WOD+0CPNy/3y+J6ofKYYzyw3E+3WdAxRp+wAX/G5GnBp46v5bp7kGQcCMiIPSKX4zHaTB0d+1yL9GdF3px41ifoD3ry64TsZ1rgHhA4Kr6HjoTlI8hbfWoodAQhxr2NgfriqxPKrw4GdH+WdG/1SR/WXdkP40eo32C/Y9r6TPw2/e6CZ77PUvm2XBovL/XvDszHqO07qNebPJh7ATPmKOwz4VnZo7B5S4qq50p3jCX8LNSXcUIHjIXKZ339OLaH0kFtv1Fxk7ffqH54bN3E/vQPHaFjjJ9ONMZYBOPTD7zMxxg8Z94NY4xdhNMbYzj3yURjjG+8aozvVyuOMXgrVasxhqWZffsEH78+YPL+L/R9P014QyAL/Sa/Pxru0Rdrgj+/53UFo/8daPdOKTI+LPhfS/Jwjkyt9bBPvFbo5cunasPYbn9G6yG8dbjpoq4LQ/5v2AcqYsfUH1Xn1fihLtJqEbrc/4+bXr1p4F2f5XpluvCzmL7MawW92YrHzU0XdZ0/BDIcybY09O0DlDYF0g591sONbekZJMyy+sXYD/EbIu0BuC9TFgprd0KsXRWxRtx4H8V6qPpoPHej5pnzcuw7/qV7FYdeQ7qWjUPIXyYO8bqN0X6f4hC/Xtd0UdeZof6JYe+viB0bh3x9AtSrLtJi4tBd37vwwU9f8/mjMzcx3vaLZzFb0l8j6Nus52eoOMSxBuPQfkrDOGQ6qDhUsU05I8Z+iK/mkjgOxZaFwtqdEGtXRSyLQ6G1BYxD3L9Tr9hiHOL1rPrxYzS148djheaqVf9N9TE5bY/AzGUvKGRbmsWrgeLvlZDG64FqjG6/8Rn6OvLwOrrRj4Bthkk/3ld3tNBPlRfusZl9vJ/u6QBdqH+v1sFDff/YclGvHPHeB/W6Nj4L7X0wOm6TjoMyODrQlp5PupRtS5Hf6Mw2oWMvnhQ6tBoffpPKs1NzOmbf6T/4N6+4L7Zxr9uy9dq7Nr11yx3Xbtn81i1b+0kDPiCFa9U+0khdpiXv4H6UfvPOv930e4/AaSVT7dQ5B+5ZbsxOnXOEzodTznltyjlPyBlyukzUX5PDz0K7Mc8jOb7dKWcfP8bDLZmqzVcVf3l3ytGnj/G9hqJH7K7XC914Xcra+cKenI7KuahNORcJOZ2uBxdRfrBlZruV3Q2G/LsnWU6rer0xUb3+g9PG+G6IqNehPIZ2P+4SeTSsPS2wriIs5A+9OL8rQk7o8IZdkXJi8hOSczjzY1hqJQrL4JqAXrziu68F1tWEhfz8EvnOgM5lD2RD/tDBb3vblLM3Us5k5Yd36uCI7ULSQZXdvoAOyM+zfJ1aVbuQ5Phi5LspRqpdAMjLb6IY/a9DjPyRQIxk332l2blTq4F86KCvPHdRearVwFB5Gv0HoDz3RJSnss3OQH7wTZ+YeBhzeMneAL2aBVXtgNmXd1/lV5srNdGfaDT8OulSUt6hF8PVTjXMH76APae4L0buF255aMXKVRf/YNj+zge3sk0NdyYKdeN3oyG9o9/Ml+tWI5p9QkZ+sf/sJzoud3vO+DE6taJtla7qzUGiLduuIf9OD5bV+fzCN3l4V6vR/3hRz9WbPKofpXb1htpwrndM1y/yMM3D93an9cM8rw/k2eg/EMjz3hZ55j636u+p3Wi80sV5GHQTfQAxYvovODN3thufr7Izp2cLOZ2eTTyb5Pjau49Se6d2buHM7TuKe559Pwjt3ccD7d1k5b9Vnca8sE9hvmoeTN7VYvS/UeS9zd0h8m1Z7pMNCf3z/H2KylTlPVSmRv8YlOlvR5RpqH6E+iIqTuwO0Ku+TuiglvQ7bLKvxPgo4qvV6yp9EbUrRq1Mlu2LGO6fQoZQ/1Z9EeZTfZGnPTJ8dY/7B9yXadUXUTr5aNvpi/Bu4rJ9EeQ3OvPPiocaNU2X3aCH2jXkm+/pcxProqJX/Q/E57LF3SzKNnzIoNF/EfoZp9NuQdThfI9+zsWVBfLzQXO8zqb+mhx+FlpN5ZXITsxj51fo1ID74B7TTI4vJjcEf2gee3+bckI7QFr5+tuK+1Z9or+m9lMdPD4k9OC+8VnQfn49sBoemlfjNY7QwYvqxCq1WwH7A98M6MW7Jsqu0it9+ASegRPGdPku6YJ5vYZ0KXt6EPLzTgs+gSC/LP5Oh+cl4m/0IXaGX3cT81ylfzCd5PnsovqQxtsQaaNw75NzjZAT8h2lV8JD7EzFU4huvUe1TOBm9I+fn0LPVBcDsXM3n3bKmBw0Q72oCuZ63LQ2Xdylhg4cYtDNuJqXrVrI7zuYC5v70EE2mOfXEVbZphz5fcPBmkd3Ht4Z/fFURhW7Z1fxJi/DQOyKG3qvig09vrPiUa+6SIvZdPu1+nm/+zcffeG/cRNquvAzDhdqCPk6QW+2wumhEra6Qm26xSmK/EIf2UNpuOnWdFCbbp+uqF+M/RBfLdtthvsyZdEQaesrYtlGWTWUOFwxyTe9y2dlG/2pRd1XU50qNqkD4VRedxKfOugwvzjm5FfT6ev7dBme2X+qkOU7lOvVkO8V9OU9tYHVYkR/QIYTzzLntw3LUAdJPeTG67Y7Qje1ZQQx6h49cww1vGG/LTu8eVLoo+Rc2aacK4WcUJvEf00OPwttO7mS5PiGX2tPGOPBeOIbfm0t7nn4tQyGX+sLTDXM4WGkOihWvQzOth9weumE44nRXwH1ig8TUAdabgVMn5/VhNz8fqVHh2uoP1OxzyH7nDz1g3bg2JpflzqdJ4zTOIxjG6glrI0BejXtjD7JMRvbcN8BFL7lM5a9v4VsXhrzfWcGf6PsqwKyD7aQzduw1EuG/GLK3SeP6XAr1d/pwKPK/TLCNPo3nDSGeXtJzMs9mA/BdMMWigkY69e68fLK9j+QvzfdUH66gfsESs5aISdzE/15kqcb5hNdyumG+fSszHTDsJvoYm/05MEBNj5jN0d+o1NyjmlTzjFCTgjrjQLL6LcJ+mMEfQdcYzHRbQyoxritXGMxPfO5hl39JDO/5xknLhrWcVhgDAXy1C+ecVEPCVlKzm1tyrlNyOHF/PdR7wjll4iWj1v02w4POfLvqIgdG/kNf0jIM73qIi1mtufkX3/PT7122V1XZsRvuvAzrpJq9HyboG9z1u1RNduDi3z5hT3oHZSGsz2mg5rtqThz+2iM/RC/IdI2w32ZsmiItPUVsWy2ZzvwW905nDGjE3JCWGoGyOjNNgOCXsUko/9pGDWeSbMxyt5OPOtzE+ORfYZkWGBd4NFdyTb8/GoIfqPrYEycUjYm1t3EPFfpDav6oezCGwqQV20Q4COXyq6EvBywzDeH3ET/zTx/TQ4/YzvvSIiVYhNIyo0e6oixNXCPaYbFz7hckJ+/bLZNyFHt0HZKUy/uqZfGVlK+sE5y/C4bh4aEfmpUjrORnz1By8SZObVywXH7OyeO8f3+Cf48xny2Bel9n23579R3xVnOErEt+NmWVrb7fAnb5dc1lBej/2Ow3R8FbGe+qerEDkpDe/DquPpkQUZpzsWtniF/zNe521wxjG77DF+t8FZp+9SKrYoxba7Y1kye2gSsymGm0zZVL4RaHVOxjuMZxjo+uh/btd2UhvV7Bdz74plafR0O6DdZcVPJOatNOWcJOaF+YoyvKzlK51ax7NsUy3ZAmmoH3lnc14j+P0Ms+25gVQp15N8x4wuT51uVetKj378GVqVUnt8Z0FntssF649tl01fYaJB0LRkrZNvFnwJT/bk25UbPxht+3U2MG1VisPpEmup/5/N5s4r7Ymrz8gc23bFm04MPPXzvlj6EduNLjK2CqPgsc+Nzj2n99OwRoltHv9cLPiew+0Fuig9nMR/awolnfYL+ScJ6UvCZ7v0BfsRQM0GGofjy3z8seLp1RMNblpGuzd7s7NiayfvfKn5A9VDNVPszVO8otBdP7e3Cj69iGsqJ2duV309PiHV0D6uH1cPqYR0GLDUK41ksbKd4rw3GQR45lV24VvsdlJwr25RzpZAzJPgyz1+Tw89YjtJZzbaw3crOQCI/H37qG6FdcaKWGTtCM/pPwgjtqhPH66xGaM7p0TCWg2Ew7yDoYGkl+hfD+SjtHPp4G9oVVyzzf6F+SH5vewzV/s0hSkNfiC2jm6mMpkOaKiPe22n0Pwll9MbiXu3jitlHpORllOcBD/100s/oNxc64SpdaO83y0N7oJ2v8Mi7E+SdCP5g+XQku02/m638Dvdcsd+pmSD16mAoXqi6pWZZtxGW2ruHfsAzJ8Y/4HQZ4DtNSP9WUeaxfs7lavQPR5arPetEuaKtuFy3QVqonQr5AZaX2UTN1I0SVqs9flyuxu+ry/yKqtGPBsqV3yXhNoLL1eh3RJar2bIT5Yq24nIdhTRl25hNdaNAw20HlvmjlKbefwnFb7VnO1Tmqk/GZb5XlLmawY/ZjOjbdzq7uC9m4K7d+sBbtxRTcI6u0JRZ/vtJjxqzBL8j3oyezaI0FT53wLP1HtkDTk9Zcfg0+ueEyUPhN79itlRjcXdiEtfwU22pjt26bHkfFbo0RFoXuGp+rfOokQl+R1iZeJZfrbY5cy8wZGJlKrVXK9RyGP0HAi2HagnViMjoVc8dW0fTR+Wf3yRDvp0eObEtmtF/OLJFSzTykS0a2ohbNDWzoN6QM3q1no2zDVzVcG2Ze6dqPTi2GvKnR5WfqpGV8pdQjztkH+Vfal+D2lsRGgUbXSdGwZgf9oVQ2eYX22avoMfy5l4r7i3gmSesl7435FBOrC/gbAfPhOyIxDV6dWAcNuE8Kjf63xMxwDDVilzZESDGcdNHnRzxFKUhH+4rMGxHdG3644yUszL5VbWuqllS3juObYFvFgftjXshJmsPFrffT4Muqj3Gt2GR/iswa/RNqiOqjofKQO0/wnrP8RLjxb4IrO0B2ert0X0B2agXH4bIB3urPVKqrpht2qwrU1RdwfjMdSUUi/MrxlaqnNQBY3w49zZIC+0H49M4YveD4RvM7J+qvxjbNuC+y89T3e30rD33if8F2ohjPX3i2Nlgo/+3QLuj8hBqd1rNkHPdwtjH/Ww1K6liH8fF0EcXsH5yXDS/xrqI9L5Da+snvfS3k4fWcuzGUziwPeM9wEa/BN4GHzpJY04pidkocFqNWRLFulqnY12rNon3qWLZbCes2L2oXM8GnB4vGR6vth0FZcAzbduAn2MqxluOqTuF3NC7Brndzy/0UP01XMFaSr6nxsvIy75n9KvBn48r7lPGDT5dCeMAj0HLHmiO/DEHere55zt6T/uheOYm5rnKVJyqf2rOoM24eWhPu+qrqHLAPe1qHztiWaya7LgWmotpZVd+PwjzyPV5G6RxHIjpkyl5vj7Z+VT3U/XJPkt9MqxfXP+xjnP9VwfgqzEA9xv2gS6qz4NtNtKvgxh2E9lG+XJojkV9YAb74jymR18/EIEVmutTJ+IcCMhGvfhDNwfot6qTqi7ixyvyK+V4CvsFXBdDY8n8irGVKqcG0aNtytZdHoepjw+ouounMt3kabcxH9huc919SuiK/QE17/56N15m2V1dyN9Nx6u8XmAZ/aign6TjVZYR3caAaoyb0T9+voye9QtavCZrMyFjYQh/ErCuJr1Ggf8mwhoVeo0G9EL+UQ9WzaM7D0mNfgcNSbcBT4lweDD0+libxwwczAjPOd0tNfwhIc/0qnr0yq/83NUzPv/pVVFHh+QXV1c1LX+ToDdbYRgsYat9oel2XD51bqLN8gubLdNBHb1S8WiYfTH2Q/xOH71ydUWsmKNXOh2T+CDOJ2CIf+yKw6OLdQX2dIEu1l060AW6WFfmeaFLqD3AKVRuW1D3UUobDeRLyRmNzFdIzs1tyrlZyBkSfJnnr8nhZyxnVOisdjjhdNTPULd2G6SpKfR7i3vevHo9HOD5QerSKjtn4neo38H64WvJSPOkR78PgX/ya8kqz/cGdMapSEcY+T33SYz+l6hPUrHfIKfJuY/Qgf5K9I42w5/sY5HyuBH/WjKWGFsFUfFZ5sbnHtP66RlvXFtLv6u8lqxe590uMK3mYZ6e9PChLZx41ifodxDWDsFnuvcH+BED+dhjFF/++27BE6oBMR6cX7xH8smEWOoV5zZ7x9FfNjb8OulStWaGNtnkF+d9t9BFLQrw6FRNtqgJudACQwqsfQmxDiTE2pkQ6+geVg/rCMZSG9t41I7vS7y5uD+cr//e2KacG4WcIcFXte1rBHRWGzDZbmUPhkR+Pq7ENxL67klaZuxIyOjXwUjoX04ar7MaCTmnR52hjc9G1+Ziz3S12IN25cWe0LE4+f09xb1aTBmiNPSF2DIaOHm8Pq1eizR9+F2hM6CM6sV9zGekQpvtUV5GeS77+u9woVOr13+3e+Sp13/za4NH3iyQNwmv/46Uff13FNL6BT3PSqt4MQo0oRcsHqU0tDHHpbKvBo8Wv2NfDTb6Y4Q/qLaoHqGfslvi1wl3eNSYKfgd8Wb0bKYHy3DyZ9vgWczrhNuAxvc64XJh8lCR5ZcKX5af3uuEXfk64VqPGpngd4SViWf51ep1Qm5VQiZWphotfpd9Ef0s4dKhCKt6WKGewCjQhF4n5K2FyLfdI0e9Tphf3KIZ/XmRLdpocd+JFg1txC1a7MyJ0auRjdp6H5pNCY1sYqth7OuE3FNL/foW+1fs61uhXnWi17emv5xe38J6+RTJUb2oWF/A0dN3PWtMPlxe81GvdWwDGt9rHTeJGGCYO4QOIX9U/qtmvUNHsqtjl0eLe+WPRtemP05T/oj5jxnlqb0CZeuqOmxnO6WNQhp3I1v5Tcgft0Fef4bWJ1FX9r1dgbzlF888ID+XO8o5pk05xwg5IayrBVao/Dq85c5UXER0GwOqMW5G//j5InrWL2jxUsW0zaO3c3HFhPwhdxhqU85QpJwb2pRzg5DDW0H2FWG3zS1VO1TTaWVn2AcrYmeE55weTRn+kJDHi2mYFrP17u8a133m3m994Ocz4jdd+BlX22cE/Q2C3mz1LPCXsNWoappMNg41nJtos/zC5sV0UFvvnqmoX4z9EF/tLN8M92XKoiHSrqmIZVvvsHmc7JjBW++ehS4UbzGbLF32Fr/f3wW62Na7Hz+Muig5N7Yp50YhJ7RhISZ+KjlK51aT/j9PQ8mnIC1m0t/oZ542xvdhmvRXds6cbr/yv7ghhOs7v8nKNE969Ptl8CneovakyPM9AZ2fAhksN7/3ffXpE9R276a8N13cFfrqk/pmAtcTtdEJn4XqyZMBObe0KecWISflJqFGQOdOyskvq3PKbrfCfRW7IX+ofLa1KWebkNMv5ODmsJh+ZsV6UIspF8Svky4l5XX8exE8dd3Oeespvz3BG7OU39wqsMraK+EQ2FS8nuiu8ajWL3Az+sfPr6dnviGwYR/O0LytTTmq6rfqWnzlZC3T17XAnd9I/6pTx/i+Sl0L1It9YJubmMdtgTwiv9EpObe0KeeWSDnT25QzXcgJYV0ssIx+u6BXe54SVmFT8RSi832rORO4rarwKfTMV4Xt9+F0h3VtylkXKeeV6t7rBFbPvcdhH85dlre0KecWIUdtKcEBd6sWbGphQGuRbGB30SljNHW4530J2Lo97pw370+QPrzlJ7+sszwKzzuxxWW0uK+TLiXlHeosj5I8zl+194vYK0fhN6Lis5Dn804W3mQ0nfiqvF+0DdKUJfj9olHA2ebhQ1s48axP0I8S1qjgM937A/yIgXzsMRk9x/7fY0J2jegXF7Uqn7q5kaZulCy0R6s9gkzj293TBB2We3b31Dz54tq8jX5jJNjskX8WRJnjTtHynZDP+cMWZcCj7yjpYPQngg140952we88z9AGyOv7jbSDlBf8rXzxMaLfUfz25Z3L3+hfFSj/IaGD6ZVfZT/+O+jR4dVCBxE11zzw4Ds9+/W478BRbpR+c0kMCRzfZdbIPda8l63DtYPl2G/lAXnO5xT3h7pi927Z6turyC1C3SOzz+lryKObc2Ntc8W2MrptNvy6057XdFFXxtHT5HH+QttPjVftLfHV0lZy2tx+6mu0VbBgfke8mXiWX7k7f2P4pXu1HYk7JmpkoV6vVt1lo1NybmlTzi1CDmP5JmruKO65gbgMAtSJntOD+wRmfvHEnNoed4vIj9GrCS110mjo5e2QbLQlB/RdJXV9StDjGhOfDoj6xWwjRF2vmmRdtwtdQ2udbb6cHR06D9fL2eWGNfyqMVoFUfFZ5sbnHtM4QnJjewn9rjKsUbP7uwSmOj93t4ePPZuf9Qn6pwjrKcFnuvcH+BED+dhjFF/++12CJ+Vqv2HtToi1R2C1eS7w3NiayecC76kmL3gusFrpsrzvF7o0RBqvqKmzOfcLOQrr6YRY+xJiHUiItSMh1tE9rB5WD6uHFYkVOitcvcT15uJejQ54RLdD6LcjoB/y7wjIuaRNOZcIOeqFlMzz1+TwM5ajdFbnn7Pdyu5AQf49lJ9twIcLNh84Rcv0vdx0T3HPO3ObsOXg/zvFn0e0s+WLdW7zBaMh9YIR9nFizgzHPtx7intVf/hlRixrw2hVBh+lMtgBaaoMTB+e7qxDGXycygD5sR776o2Sxz7ie4d9B+ln9L8qpsOVfrs88nzf7/sRj7zfELMrHXyxbW7Z7zbG9rtj/dRsovyUZ2y2CSz0A56xMX7fZ5ANj7ci/a4o81g/53I1+s9FlmuieDK37AuLamZNtUMhP1Bb0RpuYpn7ZiIRC8s6ply3CXwu1y8GytX4sVxRTy5Xo/9yZLmaLTtRrmirmHJFei5X1X6rXb9qB+koYakYHZphVeWKZcAx2uj/IlCuapY7FIeN/mtdEIfRVjHlqlYCYsuV4zCW66OUhm0d1+VtQk4nYvS3RZmrPv+2CP2U3dpcpOLdAE951Jgj+B3xZvRsjgfLcPJn6tNKXCUGnJ4CZZMb/fcidwagPipEWX4O11nK26rJC56lrEKq5X2n0EWdmlW2WeyAq+bXJR41MsHvCCsTzzBNuWqV4wem0kgBXYhHCiryoQv4ZjB9vQvD4/cZh4uRjGqFQr3g/OJo3eoLT6aPyv9BSkO+XR456qudqnU0+rmQ11DraLI70Tqijbh1VO91h94Df1bQ47vUPKuE74FzlUYbHyQ5rUIH+7/yUzX6Vr1xtfUixh+Vf6FP7Kc0NZpTvmB0nZgpwfywL4TqUn6xbUK+g7ZpuNZ+gvVyP8kJxaX8CvkCzi58gGIh5odn5/qETHwWmp2zNCVnW5tytgk5jBW7T8XoV3liFOuSef6a7vyMdUd9+RDWTsl5BPg4TZ2myG1+fln3q2I9jH4v0/DrpEtJeYe6XzWSx/nj7tcUoUtDpD0A95iGcqYIOQprR0KsUL27gOSUrXcXRMpZ3aac1UJOp+vIBSSnllAO1pnVJGdKQjmItZHkDCSUMwA0K0lOJnTI9XrjqWM8+b+pkNYvePkr3Eb/S7ACsKm4Nx9E3VFH5Of4xflgeW8qZFj8483lTRd3jQCfI6xWtruLbNcPaTG2M/pnwHb3kO1QL67baKcapU2FtCmUxrbCPKjtv/iMfQ752W7Ix+1VxdN4o79gbvh115Z/HGqv6iQP855fZhfL37Rq8g59wVy9UqfKAb9gjjZF+YbF7Sb30TAN6+MgpWG7NpXSsH4X3TXpyzNINpcnP2O/Y36FhXlYKfSqEf0zFFPQPiXK8OQO9tdOjvV/wx/yyMuvukiLOa/tUytHzvnMeb//5Yz4TRd+xn6m+lEzBL3ZaoB0b7qo60Q1fjXZ/HoM28y58X5uOqjz2qZU1C/Gfoiv6ibvyIktixHnJsTvUPvCadi+cNszKHRXr9lyX8Bilmo/EbdG9C9A+/kRapNVHJ0Kz9g3hwQ9v5uC+cE4OxSB1R+QPSzohwKyUS/kZdm+9kDVD7NNm/M7U9T8zjQkAFxfOSF9jK1UOTWIHm2j2sF+SsP8T6M0zAO3kejbdcjzRzx9RsxHBs94/igTuqq+qOrHhXxP9W/41bD8UvWfjyBHPo4bWP85bqCPctzAsuW4oWI50vMYwuh/jdp79JF2xxDDpCP2wZR/89jA6P8HxLbf8MS2KSUxPx0572/l2GYsqKlYgPWdY0EoBudX2bjJ9RbLZiphTRVYaFNehjXbDAh6xKsR/efEOpOKR7zLD8uAjxOP7ZdbfXjx/chCDzVmw7HuH5LvYUxT4xP2PaP/JvjzF2ismyJuDFAaxgHEYJ8K+VlD8GMbynwWB9r80k30WNfw625inquMdVX9U1+gaTNuHhrrNoQ8VQ441kWbonzD4r78ZMU1tFNMXFPr5mrdhuuzWitQMYLjx5SAPIwR2Bf/hmeOEPORCVzVZ8H5xTdS/cf6xfUf6zjXf/R37jegDbnfMAy6qD4PttlI/88Qw2acNh5T+XKoHztT0DeAZpDyg74+MwKrHpA9IuhnBmSjXsjLsn11UtVFs00nxhvYL+C6qMoJ6WNspcqpQfRom7J1d5jSMA9cr9G3cf6C/TPUz88vrruDQlfVH1Bv5IbODNgNWP2Ekd/zp2yMfk6RH3VugVqLD+2f2CvocY+E6TNMOiCvelMa3yQ2bMbsxKeVJnPHP/st7ovYTWnqza5YvwntJcPzz/ls9Fa+wP34pwFL+cLDxX2N6E8I+GNod31+sc33CXq0uekzTDogr9rPY+XRwf08w8ofMT8xbz4hPdvmgKBHn+M5HXw7+mlKw3psMocIB+2d6772hPF0T4M+meev6crPeFyB5Xg06bM3oRz0CV4fxvqC477zqf3YB2mqnrytuK8R/evhmwOri3u1L20v8VvaGqhnl6/w85stVR3h80/QHrynUuUT6R/25HMD6HllYG7F9Gqz3jXK1ju1jy5U71rto+NTGNQ+ulBMRv/2xeQBF46HHJM3Qhnw3Apu1d5Huu8qqbtqT1rFkb8+/qX7YdKB45mvPVBlFXPSxD7gUXNkbyP6Z0Buv8BkevMJnN9EX8A5WqTfBGV1zQqN6Tw67PHoPOChP0g6GP0W4S+hOID+f4Awjf4uwDy2JOY7PJj3BPoaqp6G9se22ivN+8/Rjs9SGurO7eIzIJ9p303yMQ39nOW6gL6qTQ3py+2NpW2H9uptxX2b3w/rD5XVfULf2LLaE8gfYxkf7n2IqSNoj/ecpjGnlMQcFW266qusAPztnv6Ic3pcw3FZfSsD+zmqb/A06W9tyBOiPnauj519RbX1+IoYt/XKNqFPWYf65BjDVXtzOqWpflcmdCjbluLndD91/Hjc0PsT+f21pEerPt6dxT3H4ecDcVjZMGTzVuManmfA8jhAacpnJ9sfQ+9whPKaXzHvT+G4jv1RtR/KH7mf1eq9m5A/7oW8fpT6dgeEPipGsz6t+ty8J8Ri/ICHnmO+0X8o0O95TugQ8uPnBf1zQudh0gF5WTbWS7TJBsqP0f9yZDy2cmlz7CU/dY92Y/8P2Si/2KbvFfRoK/6O53sh7VlKw7jxHKWh//G7bqrOxtYN483tsIti9f5I3ExgqTjJsdroPx2I1Sq+hHy8Vb3kd+qw/j9DaSpWKV81uk74KuaHfTXU58wvto2KF1jHOVZjbDhAaeir+H1d9q/9oPu7I/oCobJtNffK8Uv1I1U7zGPUvQE5qJc6wWFvQM6Fbcq5UMjp9BzkhZSffYH8lJ0LQX6e492XMD9KZ5OzG/hwTvX/0hgG/bhf8HJ7Z/T/BmOyv6TxS2itKtZ3fXOiag4pv65yY/l3rhN9Tr3OO5l9Tu5XYhzfTVi7BRb6HradRuNIx07YC+tzzJhRxY2QfbFO8Fog2pLfs0Z/20tylC1j+yG41rzx+Nb6h9ZFW/mHyVLnNvCc2gGR38nur07m+QvsC9g/2E9pWP7cJ1V9RxUvuYx9fUdeszo0ri4mNWL7jiG/Sdl3VPP8HYwhXe03ob5jWb/hGILxHNtoa79Dc2SZG99O+r7R61tf2UM4GT2fBs+R70HKM/eRGPstRI/n5vQFdOe+yHKoK6FzcxTmW0mHAy102E86GP1JQoeQ/fMr1CccdBPrYol6E322guHXnfaPpou6MrafyVN+kF9cl1V9wjQey6gYqOq5wtqZECvUv+WzFcqebIz8ewJyVrcpZ7WQo/ZmZJ6/JoefhcaTfLbCgYRysM6sJjkHE8pBLD5b4ZmEcrA94r0zvnHehtPHeLDd8o3z+J0Jo9//qjG+ywtMNWZGHZEf2/19Ih8s7+pChsU/nKspEY/ke1GG1cp215Lt1FpNyHZGvxVsd33Adly3VR9j2E20B/fpcX6W117V/C8+Y59Tc+RDgo/bK5wHLjNWjKkbiF93E/Ncpb1S89zYJ+T3Td5XTd6h903eL+SpcpjptE1RvmHx2Qqqv6Fi4/OUhu0az9Nj/V4B9yjDlyf+spPST/VDse+m5lvY9ya7r7S/mrxgX0nND5XtK/H+q27tK6Ge3FcqO+eK/PsCcla3KWe1kNPpud1eXyleTpW+0q5EfaW50N7vofYeY0VMX2m/yAfLO9AFfaVnyHat1hPYdkb/3dPH+J4P2I7rdq+vNKYnPkP8Xl/J31dS/Y1O9pX2t8gT95WUfqq/k19NF3fF9KUwfyXKbmmsbxp+qr5U7Bm9lr9nqslr5r42reDDfuwmuFf7n7C8UpVf6Guck11+e6rJC5afmrNKWX5Yt8qUn6qb58A9pmF+Qv1K5J+sfuU5JMfXxv8WtfFqTSu0Z8DoPw9t/O9QG6/ei1PjxdD7rYm+fNTfze8Tht5v5XFfqnXrsz3r1hngvk3wct1G+gNCD6Pnd2mYht97MfovwhrM8hVaZ997L7512C8H1mE7/d4L2pnfI0G+0Dqs0bVZJ5aqOoH54ToR2pOXX2X38LLfY1/2AGFx/cqvDQIrpOueNnTlcsSy4v3G6vsZmB/2S6P/uvBLVf5m806Uf2gdXtk0tA7fyqY83xXaixxah1exN3YdHmPIb03yGJXnDN4LuvQLXQ23RvTfhzZ41qvGY9p4ybm4OqvGZzjm4v1IODZ7fwRWKJa+IOjfH5CNeiEvy2Y9ja+DdUvuk8OxNtctVU5IH2MrVU4NokfblB0vv5fSYsfLz0Oe2T9T7aHhOSsVq0K+F9tWhd43UfWf44Zq41Rd4riBZctxg+dBmJ7nGo2+WZSFjb/QR0r4upxrfIF0fB/ooPyb5xCN/myYf13miW1TSmIeX+C0ametHDtxrhvWd44FoRicX2XjJtdbLJuYd4PRptyvNxsNCHrE43erVkAZ8JkKGI/eR7rHzt/x+0pqDeHF/buFHup9KxwvryLfw5jWL3jZ94z+BvDn1xb3KeMG7+3EOMD9VNXmKD9T/TNsQ5nP4oDFFfTFTsyJG37dTcxzlXmr2DnqNuPmoTnxHxXyVDngnDjaFOUbVui8yk7GNbRTTFxT8+QNNzGPofcPOQ5gjOD4cTAgD2ME9sU3Ut1XMTK2z4LrkLtovIH1i+s/1nGu/+jv3G9AG3K/4QXQRfV5sM1G+jdCDHsL2Ub5cqgf+2OC/keB5jnKD/r6j0VgPR+Q/e8E/Y8FZKNeyMuyfXVS1UWzTSfGG9gv4LqoygnpY2ylyqlB9GibsnX3BUrD9p3rNfr2+yHPb/G025gPbLe57j4ndMX+wGTt/Us1V/BuqLtPd/lcQWi+vTdXMKZPqxibcq4gdh9iirkC9k+1/hbb7uJ+32sj5gpCvtepuQKOG900V/CjL4O5gl+G2PbjieYKfqo3V3Ao7XDNFXw4MFeA8ajTcwV/EDlX8LFEcwWfB3/+RGCuoGrc6M0V9OYKXgQv/r5S5wowRnR6ruAPOjRXsCEwV8D1v5vmCr4EMezrvbmCCbJ9dbI3V1Cu7qaYK/h6h+YKuD/Ae6fy6wZ4ht9+YH3VvgvuZ/H5fUzD56ca/behn7Wc/EPt7crz9o+evPn2vvDZgUY/94wxvn+mvo46D1jtw9kLOnL8ZNrNTtugD/T4/qv8smwteSiQxxyjdoafbrOgYwx1zjHvm3la8Kn9Zrw3/CDJOBCQEXvuzD7CRJuptvC5FunPirw58axP0B/05NcJ2c+0wD0gcNR8Ju9b2ivSMjexTll+8fslHF8wLuC+pU8uf+k+dB61/T7k54L2YEB3HvuFzi1Suiv7YfwInTlrv9m39op8ZuK36XcXPOMYi+eU9Asa4+V3nJYW9VbtT1XvTaFeb/JgHgeYJ3r2vDrAPBOelT1fit/fVPVc6Y6xhJ+p8tlFtLy/c7PQyfd7v8Dx6bBP4Ki4GXOGb2zdNN683H+a6ib2758i3feQ7kjL+1vxt/LvIaK3vKJ/Iw37t9GfHfDvpyGfag3iTR7M1wT8W9n91fCs7DmbPBeLZc7vqaPuGHv4mSof9m+OR5uFTr7fTwscnw57BI7591MeTJbJ/pBfse8RnEb+jXL4PfOnhUx8xnNIO4X+/P22S8GX+LsYqKfK4wYP5hUB/1R5CJ0DuzeQZ9RHxYe9AT4sv0Ehq2k33w9fhmd1Yarz+yCfhXId2GnFCq1Lxvq0uIbcRDtnlM+K51k1M8JzTs8RGn7dTbRFlTlCFaOU31v+Kr43uQTfg0M/2gT3aq8vlpd6DxHntm89Y4zHV8cwJm0p7rmObYFx1u0eTOfai02zl4/HDdXF/Gr3+3mh992Q70lKwzLx9UvRvkjP55Qb/X1QN6/s/LdE/uGVeI4u+43vO1CGVyP6d0AZ8LrVk8DPe+6fKql77PdpsG5wPVbfzVR1LlTvUe9ri3uu99sCbas64y7Utqq2OPZ7qzyPNMnvo8ozUDE/XF9Sxy5+HzV0xjK+j2oyVezF76d+97jx+uwS+mDZsn8hVr/Q44rivkb0BwP+1apdYRsqf1R9/mE30f9DbYPVfeVfRtemf80q+z3fUF3Kr7L9WitbNZf0FKVhLOSzKnEMsAt0/wL5l2onkfe64p7byZ8pOdcSqnOt2ij+XmjsnGroe2w8znxG2AHp73Dj7WD0H4rsLyQ6O/zCw/39EJ7rxLlgngtS76iF1l/wvGFVBr7zhj8R6C9g+xSaY47RXcVdVd+wTr2rqG9qnM991r0BmcyLbc+Ah943/vyUsBfHM9/c60bCNPrfDsQD1aY+Ac/Kfv+O517VfKQaP2CMNGzGbLN+XnS4z8vg9gPj4dOU5jsLHWlRTqz/ow+9ifwf2/PHSWaoH8u8KMfn/77vEn8x4P+txuWXEqbRf7nk3FfI/1v1EUJ9JK4bql/fwf752sPdP2f/D/XPy87zxvo/+tB11N/Cb1Arn72suOfvrn+9pH/huKFqH1T5UCj28vyM6rtyOfraGR6nGP23I/tbpleb/jz7cMdzXntT/dtQ/MSyTvVddzvIr9X8DM8tPVVS99j6hnXqImpvcOzL7c1TAZnMi/Xa194YHrcN04S9MpLhmw/i9sboZwBmzHg91N60Gq/zfBDahdsi1D00Xje6NuvnHFU/Mf9cP0N5za+yc2Xc3mA83EVpWDe4LxM7z9NqfH964f/t2fUdH8lAF8PuF5Q1+ms0S4syqYN8+1uL0ONLn/n2H33s0pX3jRB/flkZTWsDf8ZnPnnln333weM7hb/o17b8wQ/9yV//Safw/+/gVWv7/sPuJZ3Cf/z/fP+Lu9+98O86hX/+j7/9yaGzfvGXOoX/4en/46L/9OODb+wU/h9M/Ztv/d7v3LmvFf5wcT8A6f3EM7X4W4O0AYFXI/rXFnUsr5vnU19oipCXP7ssQJd5/iqdUR97Vhf0/YLeZE8T9JY2HdIwhiMN2gux6pCO9BuKvFuZDAKP8TeE/EGSr/TGZ31EP13QTxf0L/ZfKG5i3suuoefXAPHjM5TdTl147fKnFyz67FuGOlXXPnrWqefOuPH40U7hT6ktel/zF2+7vFP4T66sjTz9+ivWdwr/vd963Vk7Fiz7+07hP/vbp63/+6u/fkwr/P8f3DV135ZcBwA=","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"3690545947287040499","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2468625083757737193":{"error_kind":"fmtstring","length":22,"item_types":[]},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"9209611950039026975","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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1FqoUSABGdiAeR2S2MwuUYEGdOAojFxyIQEZGGfBgX5d6iQK32TW70hsUJdIQAY2YAcKMNqhT1S0r+KMFWesHSjAaF8JNKADR6GhNw1qht409KahNw29aehNszoGc+AodPSmUx2DM7ABoeZQc6g5xo5j7DjGzsC5DYydgZYcaMmBllyej2MYaMmBlhxQg+cJnid4nuB5gucJnqdH9Rstzy80oAOr32h5fiEBoQbPEzxP8DzB8wTPEzxP8Dxx9RsxARnYgB0YahqowFCzQAeOwuX5hVON4hjC8xc2YAcKUIEGdOBUozjI6fnEuH+Iluw9XRjby8l8y0Fie7lEAzoQPSToIUEPCQMbsAMFiB4S9JCghwQ9pBh9yBqkGA+K8aAYD5EfZs2eRNVf4iiM/EDRDpEfKI4s8sOFDdiBAlSgAR04CiMTUIySyAQXdqAAFWhAB47CyAQXEhBqA2oDagNqA2oDagNqo9Si6i+RgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYagw1hlqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYcacgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5c05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglbeUSCzSgA0fhyiULCcjABuxAAUJtQG1AbZRafzyABGRgA3agAGPtVgMN6MBRSA8gAUNtBDZgB061+a6GRIFlogEdOAojl1w4z22+4iFRYCnzQ2QSBZaJHShABRrQgaMwcsmFBIRay3VpiQLLRAHmurREgWWi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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"events":[{"kind":"struct","path":"HatNFT::HatMinted","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"hat_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"hat_quality","type":{"kind":"integer","sign":"unsigned","width":8}}]},{"kind":"struct","path":"HatNFT::HatTransferred","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}],"functions":[{"kind":"struct","path":"HatNFT::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::constructor_parameters","fields":[{"name":"_chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"HatNFT::exists_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::exists_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"HatNFT::get_hat_metadata_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_hat_metadata_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]}}]},{"kind":"struct","path":"HatNFT::get_minter_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_minter_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::mint_hat_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::mint_hat_parameters","fields":[{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_winner_elo","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_loser_elo","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"HatNFT::owner_of_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::owner_of_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"HatNFT::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"HatNFT::total_supply_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::total_supply_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}]},{"kind":"struct","path":"HatNFT::transfer_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::transfer_parameters","fields":[{"name":"_from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"HatNFT"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token_counter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"public_owners","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"nft_exists","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"hat_game_ids","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"hat_types","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"hat_qualities","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"minter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"60":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr"},"70":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr"},"72":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr"},"73":{"source":"use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr"},"74":{"source":"use crate::{\n    context::{PrivateContext, PublicContext},\n    event::{\n        event_interface::{compute_private_event_commitment, EventInterface},\n        event_message::EventMessage,\n    },\n    oracle::random::random,\n};\nuse protocol_types::traits::{Serialize, ToField};\n\n/// An event that was emitted in the current contract call.\npub struct NewEvent<Event> {\n    pub(crate) event: Event,\n    pub(crate) randomness: Field,\n    pub(crate) commitment: Field,\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_private<Event>(\n    context: &mut PrivateContext,\n    event: Event,\n) -> EventMessage<Event>\nwhere\n    Event: EventInterface + Serialize,\n{\n    // In private events, we automatically inject randomness to prevent event commitment preimage attacks and event\n    // commitment collisions (the commitments are included in the nullifier tree and duplicate nullifiers are by\n    // definition not allowed).\n\n    // Safety: We use the randomness to preserve the privacy of the event recipient by preventing brute-forcing,\n    // so a malicious sender could use non-random values to make the event less private. But they already know\n    // the full event pre-image anyway, and so the recipient already trusts them to not disclose this information.\n    // We can therefore assume that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // The event commitment is emitted as a nullifier instead of as a note because these are simpler: nullifiers cannot\n    // be squashed, making kernel processing simpler, and they have no nonce that recipients need to discover.\n    let commitment = compute_private_event_commitment(event, randomness);\n    context.push_nullifier(commitment);\n\n    EventMessage::new(NewEvent { event, randomness, commitment }, context)\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_public<Event>(context: PublicContext, event: Event)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    // TODO(F-224): change this order.\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_emission.nr"},"77":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr"},"79":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr"},"100":{"source":"use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr"},"105":{"source":"use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr"},"108":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr"},"112":{"source":"use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/helpers.nr"},"115":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr"},"116":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/utility.nr"},"125":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr"},"126":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr"},"127":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr"},"128":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr"},"129":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr"},"130":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr"},"131":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr"},"132":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr"},"149":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr"},"169":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr"},"171":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr"},"173":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr"},"181":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr"},"186":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr"},"187":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/storage.nr"},"188":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr"},"192":{"source":"use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr"},"204":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr"},"229":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr"},"232":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr"},"233":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr"},"235":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr"},"236":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr"},"239":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr"},"250":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/zac/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"270":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"308":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"329":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"339":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"352":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"353":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"355":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"367":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"383":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"385":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"386":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"391":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"395":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"480":{"source":"use aztec::macros::aztec;\n\n// ============ Hat Type Constants ============\n// Based on ELO delta (loser_elo - winner_elo)\n// Positive = underdog victory (impressive), Negative = expected win (less impressive)\nglobal HAT_CROWN: u8 = 0;         // delta > +200 (major upset)\nglobal HAT_LAUREL_WREATH: u8 = 1; // delta +100 to +200 (underdog victory)\nglobal HAT_WIZARD_HAT: u8 = 2;    // delta -100 to +100 (fair match)\nglobal HAT_TOP_HAT: u8 = 3;       // delta -200 to -100 (slight favorite)\nglobal HAT_BOWLER_HAT: u8 = 4;    // delta -300 to -200 (clear favorite)\nglobal HAT_BASEBALL_CAP: u8 = 5;  // delta -400 to -300 (strong favorite)\nglobal HAT_DUNCE_CAP: u8 = 6;     // delta < -400 (crushing weaker opponent)\n\n// ============ Quality Constants ============\n// Based on winner's ELO rating\nglobal QUALITY_TATTERED: u8 = 0;  // ELO < 800\nglobal QUALITY_SHODDY: u8 = 1;    // ELO 800-1000\nglobal QUALITY_PLAIN: u8 = 2;     // ELO 1000-1200\nglobal QUALITY_FINE: u8 = 3;      // ELO 1200-1400\nglobal QUALITY_ELEGANT: u8 = 4;   // ELO 1400-1600\nglobal QUALITY_MAJESTIC: u8 = 5;  // ELO 1600-1800\nglobal QUALITY_LEGENDARY: u8 = 6; // ELO 1800-2000\nglobal QUALITY_MYTHIC: u8 = 7;    // ELO 2000+\n\n/// Compute hat type from ELO delta (loser_elo - winner_elo)\n/// Positive delta = underdog victory = more impressive hat\n/// Negative delta = expected win = less impressive hat\npub fn compute_hat_type(winner_elo: u32, loser_elo: u32) -> u8 {\n    let delta: i32 = loser_elo as i32 - winner_elo as i32;\n\n    if delta > 200 {\n        HAT_CROWN\n    } else if delta > 100 {\n        HAT_LAUREL_WREATH\n    } else if delta >= -100 {\n        HAT_WIZARD_HAT\n    } else if delta >= -200 {\n        HAT_TOP_HAT\n    } else if delta >= -300 {\n        HAT_BOWLER_HAT\n    } else if delta >= -400 {\n        HAT_BASEBALL_CAP\n    } else {\n        HAT_DUNCE_CAP\n    }\n}\n\n/// Compute hat quality from winner's ELO rating\npub fn compute_hat_quality(winner_elo: u32) -> u8 {\n    if winner_elo >= 2000 {\n        QUALITY_MYTHIC\n    } else if winner_elo >= 1800 {\n        QUALITY_LEGENDARY\n    } else if winner_elo >= 1600 {\n        QUALITY_MAJESTIC\n    } else if winner_elo >= 1400 {\n        QUALITY_ELEGANT\n    } else if winner_elo >= 1200 {\n        QUALITY_FINE\n    } else if winner_elo >= 1000 {\n        QUALITY_PLAIN\n    } else if winner_elo >= 800 {\n        QUALITY_SHODDY\n    } else {\n        QUALITY_TATTERED\n    }\n}\n\n#[aztec]\npub contract HatNFT {\n    use aztec::{\n        macros::{events::event, functions::{external, initializer}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, public_mutable::PublicMutable},\n    };\n    use crate::{compute_hat_type, compute_hat_quality};\n\n    /// Emitted when a new hat NFT is minted\n    #[event]\n    struct HatMinted {\n        token_id: u32,\n        owner: AztecAddress,\n        game_id: u32,\n        hat_type: u8,\n        hat_quality: u8,\n    }\n\n    /// Emitted when a hat NFT is transferred\n    #[event]\n    struct HatTransferred {\n        token_id: u32,\n        from: AztecAddress,\n        to: AztecAddress,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        /// Auto-incrementing token ID counter\n        token_counter: PublicMutable<u32, Context>,\n        /// Map from token_id to owner address\n        public_owners: Map<u32, PublicMutable<AztecAddress, Context>, Context>,\n        /// Map from token_id to existence flag\n        nft_exists: Map<u32, PublicMutable<bool, Context>, Context>,\n        /// Map from token_id to game_id\n        hat_game_ids: Map<u32, PublicMutable<u32, Context>, Context>,\n        /// Map from token_id to hat type (0-6, see HAT_* constants)\n        hat_types: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Map from token_id to hat quality (0-7, see QUALITY_* constants)\n        hat_qualities: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Authorized minter (chess contract address) - set once in constructor\n        minter: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[initializer]\n    #[external(\"public\")]\n    fn constructor(chess_contract: AztecAddress) {\n        assert(chess_contract != AztecAddress::zero(), \"Minter cannot be zero address\");\n        self.storage.minter.write(chess_contract);\n        self.storage.token_counter.write(0);\n    }\n\n    /// Mint a new hat NFT to the winner. Only callable by the authorized minter (chess contract).\n    #[external(\"public\")]\n    fn mint_hat(to: AztecAddress, game_id: u32, winner_elo: u32, loser_elo: u32) {\n        // Only the authorized minter can call this\n        let minter = self.storage.minter.read();\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == minter, \"Only minter can mint\");\n        assert(to != AztecAddress::zero(), \"Cannot mint to zero address\");\n\n        // Get next token ID\n        let token_id = self.storage.token_counter.read();\n\n        // Compute hat attributes from ELO ratings\n        let hat_type = compute_hat_type(winner_elo, loser_elo);\n        let hat_quality = compute_hat_quality(winner_elo);\n\n        // Store NFT data\n        self.storage.public_owners.at(token_id).write(to);\n        self.storage.nft_exists.at(token_id).write(true);\n        self.storage.hat_game_ids.at(token_id).write(game_id);\n        self.storage.hat_types.at(token_id).write(hat_type);\n        self.storage.hat_qualities.at(token_id).write(hat_quality);\n\n        // Increment counter\n        self.storage.token_counter.write(token_id + 1);\n\n        // Emit event\n        self.emit(HatMinted {\n            token_id,\n            owner: to,\n            game_id,\n            hat_type,\n            hat_quality,\n        });\n    }\n\n    /// Transfer a hat NFT from one address to another. Caller must be the current owner.\n    #[external(\"public\")]\n    fn transfer(from: AztecAddress, to: AztecAddress, token_id: u32) {\n        // Check token exists\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        // Check caller is the owner\n        let owner = self.storage.public_owners.at(token_id).read();\n        assert(owner == from, \"From address is not the owner\");\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == from, \"Only owner can transfer\");\n        assert(to != AztecAddress::zero(), \"Cannot transfer to zero address\");\n\n        // Update owner\n        self.storage.public_owners.at(token_id).write(to);\n\n        // Emit event\n        self.emit(HatTransferred { token_id, from, to });\n    }\n\n    /// Get the owner of a token\n    #[external(\"utility\")]\n    unconstrained fn owner_of(token_id: u32) -> AztecAddress {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n        self.storage.public_owners.at(token_id).read()\n    }\n\n    /// Get metadata for a hat NFT\n    /// Returns (game_id, hat_type, hat_quality)\n    /// Hat types: 0=Crown, 1=Laurel Wreath, 2=Wizard Hat, 3=Top Hat, 4=Bowler Hat, 5=Baseball Cap, 6=Dunce Cap\n    /// Qualities: 0=Tattered, 1=Shoddy, 2=Plain, 3=Fine, 4=Elegant, 5=Majestic, 6=Legendary, 7=Mythic\n    #[external(\"utility\")]\n    unconstrained fn get_hat_metadata(token_id: u32) -> (u32, u8, u8) {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        let game_id = self.storage.hat_game_ids.at(token_id).read();\n        let hat_type = self.storage.hat_types.at(token_id).read();\n        let hat_quality = self.storage.hat_qualities.at(token_id).read();\n\n        (game_id, hat_type, hat_quality)\n    }\n\n    /// Get total number of minted tokens\n    #[external(\"utility\")]\n    unconstrained fn total_supply() -> u32 {\n        self.storage.token_counter.read()\n    }\n\n    /// Get the authorized minter address\n    #[external(\"utility\")]\n    unconstrained fn get_minter() -> AztecAddress {\n        self.storage.minter.read()\n    }\n\n    /// Check if a token exists\n    #[external(\"utility\")]\n    unconstrained fn exists(token_id: u32) -> bool {\n        self.storage.nft_exists.at(token_id).read()\n    }\n}\n","path":"/Users/zac/aztec-chess-mods/contracts/hat_nft/src/main.nr"}}}